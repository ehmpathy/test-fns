# research: test scope name access in jest and vitest

## summary

| hook/callback | vitest | jest |
|---------------|--------|------|
| `test(name, fn)` callback | ✅ `task.suite.name`, `task.suite.fullName` | ⚠️ `expect.getState().currentTestName` (full path string) |
| `beforeAll(fn)` callback | ⚠️ `ctx.filepath` only | ❌ no access |
| `beforeEach(fn)` callback | ✅ `ctx.task.suite.name` | ⚠️ `expect.getState().currentTestName` |

## vitest

### test callback

test callback receives `({ task })` context with full suite metadata:

```ts
it('should work', ({ task }) => {
  console.log(task.name);           // "should work"
  console.log(task.suite.name);     // parent describe name
  console.log(task.suite.fullName); // "given: scene > when: action"
});
```

**citation**: [vitest test context](https://vitest.dev/guide/test-context), [vitest TestSuite API](https://vitest.dev/advanced/api/test-suite)

### beforeAll callback

`beforeAll` receives limited context — `filepath` but NOT suite name:

```ts
beforeAll(async (ctx) => {
  console.log(ctx.filepath); // "/path/to/test.ts"
  // ctx.task is NOT available here
});
```

**citation**: [vitest api reference](https://vitest.dev/api/)

### beforeEach callback

`beforeEach` receives full test context with suite:

```ts
beforeEach(({ task }) => {
  console.log(task.suite.fullName); // available
});
```

## jest

### test callback

jest test callbacks receive NO context by default. must use `expect.getState()`:

```ts
it('should work', () => {
  const testName = expect.getState().currentTestName;
  // "given: scene > when: action > then: should work"
  // note: full path as single string, not structured
});
```

**citation**: [jest expect API](https://jestjs.io/docs/expect), [jest issue #9618](https://github.com/jestjs/jest/issues/9618)

### beforeAll callback

`beforeAll` receives NO arguments. no suite name access:

```ts
beforeAll(() => {
  // no context available
  // expect.getState().currentTestName is undefined (no test started)
});
```

**citation**: [jest issue #7774](https://github.com/jestjs/jest/issues/7774)

### custom TestEnvironment (advanced)

jest TestEnvironment can access suite names via `handleTestEvent`:

```ts
class CustomEnv extends NodeEnvironment {
  async handleTestEvent(event) {
    if (event.name === 'run_describe_start') {
      console.log(event.describeBlock.name); // describe name
    }
    if (event.name === 'test_start') {
      console.log(event.test.name); // test name
    }
  }
}
```

**citation**: [jest TestEnvironment events guide](https://www.kenmuse.com/blog/crash-course-jest-test-environments-with-typescript/)

## implications for test-fns

### option 1: use native access where available

- vitest: use `task.suite.fullName` in test callback for registry lookup
- jest: use `expect.getState().currentTestName` in test callback
- beforeAll: neither framework exposes suite name → must track ourselves

**problem**: inconsistent access patterns, beforeAll still needs manual stack

### option 2: maintain our own describe stack (recommended)

since we already wrap `given`/`when`, we can track the path ourselves:

```ts
const describeStack: string[] = [];

export const given = (desc: string, fn: () => void) => {
  const name = `given: ${desc}`;
  describeStack.push(name);
  globals().describe(name, fn);
  describeStack.pop();
};
```

**benefit**: consistent behavior across jest and vitest, works in all hooks

### conclusion

native framework access is inconsistent — vitest has better support but jest lacks it in beforeAll. to maintain a single explicit approach, we should track our own describe stack.
