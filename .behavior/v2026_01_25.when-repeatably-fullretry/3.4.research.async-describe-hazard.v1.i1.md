# research: async describe callback hazard

## question

will `await when(...)` break the describeStack registration?

## answer: `await when()` is safe

```ts
await when('user clicks submit', () => {
  then('test', () => {});
});
```

trace:
1. `when()` called — runs synchronously
2. `describeStack.push('when: user clicks submit')`
3. `describe(name, fn)` called — `fn` runs synchronously
4. `then()` captures `path = getDescribePath()` — stack has the path
5. `describeStack.pop()`
6. `when()` returns `undefined`
7. `await undefined` — wraps in resolved Promise, continues immediately

**no hazard**: `when()` is synchronous and returns `void`. the `await` just awaits `undefined`, which resolves immediately. the push/describe/pop sequence completes before the await has any effect.

## hazard: async describe callback

```ts
when('user clicks submit', async () => {    // ⚠️ async callback
  await setup();
  then('test', () => {});                   // ❌ describeStack already popped!
});
```

trace:
1. `when()` called
2. `describeStack.push('when: user clicks submit')`
3. `describe(name, async fn)` called — `fn()` returns Promise, describe doesn't await it
4. `describeStack.pop()` — happens immediately
5. stack is now `[]`
6. later: `await setup()` resolves
7. `then('test', ...)` runs — `getDescribePath()` returns `''` (empty)
8. wrong path captured — context lookup will fail

**this is the real hazard**: async describe callbacks cause the stack to pop before nested `then()` calls run.

## why this happens

jest and vitest both execute describe callbacks synchronously:

```ts
// framework behavior (simplified)
function describe(name, fn) {
  suites.push(name);
  fn();  // called synchronously, return value ignored
  suites.pop();
}
```

the framework doesn't await the callback. if `fn` is async, it returns a Promise that's ignored.

## detection options

### option 1: runtime warn (recommended)

wrap the callback and detect async:

```ts
export const when = (desc: string, fn: () => void): void => {
  const name = `when: ${desc}`;
  describeStack.push(name);

  globals().describe(name, () => {
    const result = fn();
    if (result && typeof (result as any).then === 'function') {
      console.warn(
        `⚠️  test-fns: async callback detected in "${name}". ` +
        `describe callbacks must be synchronous — then() calls inside async ` +
        `callbacks will not capture the correct context path.`
      );
    }
  });

  describeStack.pop();
};
```

benefits:
- detects the hazard at test registration time
- warns with actionable message
- no silent failures

### option 2: typescript enforcement (recommended)

use a conditional type with generics to reject async functions:

```ts
export const when = <F extends () => void>(
  desc: string,
  fn: F extends () => Promise<any> ? never : F,
): void => { ... };
```

**verified**: this approach works. async callbacks produce a compile error:

```
error TS2345: Argument of type '() => Promise<void>' is not assignable to parameter of type 'never'.
```

note: a simple `fn: () => void` does NOT work because `async () => {}` is assignable to `() => void` in typescript. the conditional type with generics is required to detect and reject async callbacks.

### option 3: documentation only

document the hazard and rely on users to avoid async callbacks.

## recommendation

use **option 2** (typescript enforcement) to catch async callbacks at compile time.

the conditional type approach provides fail-fast feedback before tests even run. add to blueprint.

## summary

| pattern | safe? | reason |
|---------|-------|--------|
| `await when('x', () => {...})` | ✅ yes | when() is sync, await on void is no-op |
| `when('x', () => {...})` | ✅ yes | standard sync usage |
| `when('x', async () => {...})` | ❌ no | stack pops before async body runs |
| `when('x', async () => { then(...) })` | ❌ no | then() captures empty path |

the hazard is async describe callbacks, not `await when()`.
