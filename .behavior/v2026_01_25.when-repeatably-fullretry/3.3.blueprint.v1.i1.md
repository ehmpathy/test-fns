# blueprint: repeatably with criteria 'SOME' (full retry)

## overview

implement `given.repeatably` and `when.repeatably` with `criteria: 'SOME'` that:
- registers N identical describe blocks (same as EVERY)
- skips subsequent attempts entirely when a prior attempt passes
- skips `useBeforeAll`, `useAfterAll`, and all tests on success
- uses zero-config approach (no custom jest/vitest environments)

## treestruct: filediffs

```
src/
  domain.operations/
    [~] givenWhenThen.ts           # add describeStack push/pop, refactor SOME to N-describe + skip
    [~] usePrep.ts                 # capture path at registration, lookup context by path
    [+] registryDescribeRepeatable.ts  # describeStack, getDescribePath, registry Map
  infra/
    isomorph.test/
      [~] getTestGlobals.ts        # ensure testContext type is exposed (for skip())
package.json                       # add optional peerDependency for vitest >=3.1.0
```

legend: `[+]` create, `[~]` update, `[-]` delete

## treestruct: codepaths

```
given.repeatably({ attempts: N, criteria: 'SOME' })('desc', fn)
  â””â”€> genDescribeRepeatable(given, { attempts: N, criteria: 'SOME' })
        â”‚
        â”‚ for attempt in 1..N:
        â”‚   â””â”€> given(`${desc}, attempt ${attempt}`, () => {
        â”‚         â”‚   // given() pushes to describeStack
        â”‚         â”‚
        â”‚         â”‚ // register context by path (explicit key)
        â”‚         â”œâ”€> path = getDescribePath()  // "given: desc, attempt 1"
        â”‚         â”œâ”€> registryDescribeRepeatable.set(path, {
        â”‚         â”‚     // state object stored by reference
        â”‚         â”‚     // anyAttemptPassed, thisAttemptFailed as direct properties
        â”‚         â”‚   })
        â”‚         â”‚
        â”‚         â”‚ // register afterAll to mark success
        â”‚         â”œâ”€> afterAll(() => {
        â”‚         â”‚     if (!state.thisAttemptFailed && !state.anyAttemptPassed) {
        â”‚         â”‚       state.anyAttemptPassed = true;
        â”‚         â”‚     }
        â”‚         â”‚   })
        â”‚         â”‚
        â”‚         â”‚ // invoke user's callback (registers useBeforeAll, then, etc)
        â”‚         â”œâ”€> fn({ attempt })  // direct value, destructurable
        â”‚         â”‚     â”‚
        â”‚         â”‚     â”‚ // inside user callback:
        â”‚         â”‚     â”œâ”€> useBeforeAll(setup)
        â”‚         â”‚     â”‚     â””â”€> captures path = getDescribePath()
        â”‚         â”‚     â”‚     â””â”€> beforeAll: ctx = registry.get(path)
        â”‚         â”‚     â”‚                    if (ctx?.anyAttemptPassed) return early
        â”‚         â”‚     â”‚
        â”‚         â”‚     â”œâ”€> then('assertion', testFn)
        â”‚         â”‚     â”‚     â””â”€> captures path = getDescribePath()
        â”‚         â”‚     â”‚     â””â”€> test: ctx = registry.get(path)
        â”‚         â”‚     â”‚           if (ctx?.anyAttemptPassed) {
        â”‚         â”‚     â”‚             console.log('    ðŸ«§  [SKIPPED] prior attempt passed');
        â”‚         â”‚     â”‚             testContext.skip?.(); // vitest 3.1+
        â”‚         â”‚     â”‚             return;
        â”‚         â”‚     â”‚           }
        â”‚         â”‚     â”‚           try { await testFn(); }
        â”‚         â”‚     â”‚           catch (e) { ctx.thisAttemptFailed = true; throw e; }
        â”‚         â”‚     â”‚
        â”‚         â”‚     â””â”€> useAfterAll(teardown)
        â”‚         â”‚           â””â”€> captures path = getDescribePath()
        â”‚         â”‚           â””â”€> afterAll: ctx = registry.get(path)
        â”‚         â”‚                         if (ctx?.anyAttemptPassed) return early
        â”‚         â”‚
        â”‚         â”‚   // given() pops from describeStack
        â”‚         â””â”€> })
```

## contracts

### describeStack

```ts
/**
 * .what = tracks current describe path as stack of names
 * .why = enables explicit context lookup by path instead of implicit global
 */
export const describeStack: string[] = [];

/**
 * .what = get current describe path as lookup key
 * .why = used by then/useBeforeAll to find their repeatably context
 */
export const getDescribePath = (): string => describeStack.join(' > ');
```

### registryDescribeRepeatable

```ts
/**
 * .what = registry for repeatably state keyed by describe path
 * .why = explicit scope â€” state is looked up by path, not implicit global
 */
export const registryDescribeRepeatable = new Map<string, {
  anyAttemptPassed: boolean;
  thisAttemptFailed: boolean;
}>();
```

### given / when (extended)

```ts
/**
 * .what = describe wrapper that tracks path in describeStack
 * .why = enables explicit context lookup by path
 * .note = conditional type forbids async callbacks at compile time
 */
export const given = <F extends () => void>(
  desc: string,
  fn: F extends () => Promise<any> ? never : F,
): void => {
  const name = `given: ${desc}`;
  describeStack.push(name);
  globals().describe(name, fn);
  describeStack.pop();
};

export const when = <F extends () => void>(
  desc: string,
  fn: F extends () => Promise<any> ? never : F,
): void => {
  const name = `when: ${desc}`;
  describeStack.push(name);
  globals().describe(name, fn);
  describeStack.pop();
};
```

**async callback enforcement**: the conditional type `F extends () => Promise<any> ? never : F` causes a compile error if an async function is passed:

```
error TS2345: Argument of type '() => Promise<void>' is not assignable to parameter of type 'never'.
```

### genDescribeRepeatable

```ts
/**
 * .what = generates N describe blocks with skip-on-success for SOME criteria
 * .why = enables full retry of all tests when any fails
 */
export const genDescribeRepeatable = (
  input: {
    describeFn: (desc: string, fn: () => void) => void;
    prefix: string;
    config: { attempts: number; criteria: 'SOME' };
  },
) => (
  desc: string,
  fn: (context: { attempt: number }) => void,  // direct value, destructurable
): void => {
  const state = { anyAttemptPassed: false, thisAttemptFailed: false };

  for (let attempt = 1; attempt <= input.config.attempts; attempt++) {
    input.describeFn(`${desc}, attempt ${attempt}`, () => {
      state.thisAttemptFailed = false;  // reset for each attempt

      // register state by current path (explicit key, direct reference)
      const path = getDescribePath();
      registryDescribeRepeatable.set(path, state);

      // mark success after attempt completes without failures
      globals().afterAll(() => {
        if (!state.thisAttemptFailed && !state.anyAttemptPassed) {
          state.anyAttemptPassed = true;
        }
      });

      // user's describe callback runs here â€” then() looks up state by path
      fn({ attempt });  // direct value, destructurable as ({ attempt })
    });
  }
};
```

### then (extended)

```ts
/**
 * .what = test wrapper with skip-on-success and failure detection
 * .why = enables repeatably SOME criteria without global override
 */
const then: Test = ((...input: TestInput<void>): void => {
  const [name, testFn] = castToTestInput({ input, prefix: 'then' });

  // capture path at registration time (synchronous)
  const path = getDescribePath();

  globals().test(name, async (testContext) => {
    // lookup context by path (explicit, not implicit global)
    const ctx = registryDescribeRepeatable.get(path);

    // skip if prior attempt succeeded
    if (ctx?.anyAttemptPassed) {
      console.log(`    ðŸ«§  [SKIPPED] prior attempt passed`);
      testContext.skip?.(); // vitest 3.1+: proper skip marker
      return;               // jest: early return (shows as passed)
    }

    // failure detection via try/catch
    if (testFn) {
      try {
        await testFn();
      } catch (error) {
        ctx.thisAttemptFailed = true;
        throw error; // re-throw so framework marks test as failed
      }
    }
  });
}) as Test;
```

### usePrep (extended)

```ts
/**
 * .what = prepare resource with skip-on-success for repeatably SOME
 * .why = avoids expensive setup when prior attempt already passed
 */
export const usePrep = <T extends Record<string, any>>(
  setup: () => Promise<T>,
  options: { mode: 'beforeAll' | 'beforeEach' } = { mode: 'beforeAll' },
): T => {
  const drawer: Partial<T> = {};
  let toolbox: T | undefined;

  // capture path at registration time (synchronous)
  const path = getDescribePath();

  const proxyHandler: ProxyHandler<any> = {
    get(_, prop) {
      if (toolbox === undefined)
        throw new UnexpectedCodePathError(
          'usePrep: tried to access value before setup completed',
        );
      return (toolbox as any)[prop];
    },
    // ... rest of handler
  };

  const register =
    options.mode === 'beforeEach' ? globals().beforeEach : globals().beforeAll;

  register(async () => {
    // lookup context by path (explicit, not implicit global)
    const ctx = registryDescribeRepeatable.get(path);

    // skip if prior attempt succeeded
    if (ctx?.anyAttemptPassed) {
      console.log(`    ðŸ«§  [SKIPPED] prior attempt passed (setup)`);
      return;
    }

    toolbox = await setup();
    Object.assign(drawer, toolbox);
    delete proxyHandler.get;
  });

  return new Proxy(drawer, proxyHandler) as T;
};
```

## composition boundaries

### state flow

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    genDescribeRepeatable                        â”‚
â”‚                                                                 â”‚
â”‚  state = { anyAttemptPassed: false, thisAttemptFailed: false }          â”‚
â”‚                                                                 â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”           â”‚
â”‚  â”‚  attempt 1  â”‚   â”‚  attempt 2  â”‚   â”‚  attempt 3  â”‚           â”‚
â”‚  â”‚             â”‚   â”‚             â”‚   â”‚             â”‚           â”‚
â”‚  â”‚ ctx.current â”‚   â”‚ ctx.current â”‚   â”‚ ctx.current â”‚           â”‚
â”‚  â”‚     â†“       â”‚   â”‚     â†“       â”‚   â”‚     â†“       â”‚           â”‚
â”‚  â”‚ useBeforeAllâ”‚   â”‚ useBeforeAllâ”‚   â”‚ useBeforeAllâ”‚           â”‚
â”‚  â”‚ then()      â”‚   â”‚ then()      â”‚   â”‚ then()      â”‚           â”‚
â”‚  â”‚ useAfterAll â”‚   â”‚ useAfterAll â”‚   â”‚ useAfterAll â”‚           â”‚
â”‚  â”‚     â†“       â”‚   â”‚     â†“       â”‚   â”‚     â†“       â”‚           â”‚
â”‚  â”‚ afterAll:   â”‚   â”‚ afterAll:   â”‚   â”‚ afterAll:   â”‚           â”‚
â”‚  â”‚ mark successâ”‚   â”‚ skip check  â”‚   â”‚ skip check  â”‚           â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜           â”‚
â”‚         â”‚                 â”‚                 â”‚                   â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â†’ state.anyAttemptPassed â†â”˜                   â”‚
â”‚                           â”‚                                     â”‚
â”‚                    (mutable, shared)                            â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### context lookup flow

| phase | describeStack | registry lookup |
|-------|---------------|-----------------|
| registration (describe callback) | `["given: desc, attempt 1"]` | `path` captured by then/useBeforeAll |
| after registration | `[]` (popped) | `path` string still held in closure |
| execution (test callback) | `[]` | `registry.get(path)` returns context |

**key insight**: path is captured as a string at registration time, then used as Map key at execution time. explicit lookup, no implicit global.

### framework behavior

| framework | `testContext.skip?.()` | skip display | failure detection |
|-----------|------------------------|--------------|-------------------|
| vitest 3.1+ | calls `context.skip()` | "â†“ skipped" | try/catch in then |
| jest | undefined, no-op | "âœ“" + console.log | try/catch in then |

## test coverage

### unit tests

```ts
// registryDescribeRepeatable.test.ts
describe('registryDescribeRepeatable', () => {
  given('context is set', () => {
    then('anyAttemptPassed returns mutable state', ...);
    then('thisAttemptFailed updates state', ...);
  });
  given('context is null', () => {
    then('graceful handle of null ctx', ...);
  });
});

// genDescribeRepeatable.test.ts
describe('genDescribeRepeatable', () => {
  given('attempts: 3, criteria: SOME', () => {
    then('registers 3 describe blocks', ...);
    then('each block named with attempt number', ...);
    then('context is set at registration', ...);
    then('context is cleared after registration', ...);
  });
});
```

### integration tests (jest)

```ts
// givenWhenThen.jest.test.ts
describe('given.repeatably with criteria SOME', () => {
  given('[case1] attempt 1 passes', () => {
    when('[t0] all tests pass on first attempt', () => {
      then('attempt 1: tests run and pass', ...);
      then('attempt 2: tests SKIPPED', ...);
      then('attempt 3: tests SKIPPED', ...);
    });
  });

  given('[case2] attempt 1 fails, attempt 2 passes', () => {
    when('[t0] first attempt fails, second passes', () => {
      then('attempt 1: tests run and fail', ...);
      then('attempt 2: tests run and pass', ...);
      then('attempt 3: tests SKIPPED', ...);
    });
  });

  given('[case3] all attempts fail', () => {
    when('[t0] all attempts fail', () => {
      then('attempt 1: tests run and fail', ...);
      then('attempt 2: tests run and fail', ...);
      then('attempt 3: tests run and fail', ...);
    });
  });

  given('[case4] useBeforeAll skip behavior', () => {
    when('[t0] prior attempt passed', () => {
      then('useBeforeAll callback: SKIPPED', ...);
      then('expensive operations do NOT execute', ...);
    });
  });
});
```

### integration tests (vitest)

```ts
// givenWhenThen.vitest.test.ts
describe('given.repeatably with criteria SOME', () => {
  // same cases as jest, plus:
  given('[case5] vitest skip markers', () => {
    when('[t0] prior attempt passed', () => {
      then('skipped tests show â†“ skip marker', ...);
      then('testContext.skip() is called', ...);
    });
  });
});
```

### acceptance tests

```ts
// repeatably.acceptance.test.ts
describe('repeatably SOME criteria acceptance', () => {
  given('[case1] flaky operation that passes on 2nd attempt', () => {
    let attemptCount = 0;
    const flakyOp = () => {
      attemptCount++;
      if (attemptCount < 2) throw new Error('flaky failure');
      return 'success';
    };

    when.repeatably({ attempts: 3, criteria: 'SOME' })('[t0] operation runs', ({ attempt }) => {
      const result = useBeforeAll(async () => flakyOp());

      then('result is success', () => {
        expect(result).toEqual('success');
      });

      then('attempt number is accessible', () => {
        expect(attempt).toBeGreaterThanOrEqual(1);
        expect(attempt).toBeLessThanOrEqual(3);
      });
    });
  });
});
```

## implementation sequence

1. **create registryDescribeRepeatable.ts**
   - module-level registry with current context pointer
   - anyAttemptPassed/thisAttemptFailed state shape

2. **update givenWhenThen.ts**
   - extract genDescribeRepeatable function
   - refactor given.repeatably SOME criteria
   - refactor when.repeatably SOME criteria
   - update then() to capture context and add skip/failure detection

3. **update usePrep.ts**
   - capture context at registration time
   - check anyAttemptPassed in beforeAll/beforeEach

4. **update package.json**
   - add vitest >=3.1.0 as optional peerDependency

5. **add tests**
   - unit tests for registry and genDescribeRepeatable
   - integration tests for jest and vitest
   - acceptance tests for real-world scenarios

## risks and mitigations

| risk | mitigation |
|------|------------|
| jest shows skipped as passed | console.log makes skip explicit in output |
| context capture time | synchronous describe callback execution guaranteed by both frameworks |
| nested repeatably blocks | each level creates its own state; outer success skips entire inner block |
| race conditions | mutable state scoped per repeatably block, not shared across |

## notes

- `beforeAll` and `afterAll` from jest/vitest are NOT skippable (framework limitation)
- only `useBeforeAll`, `useAfterAll`, and `then` support skip-on-success
- skip message format: `    ðŸ«§  [SKIPPED] prior attempt passed`
- API simplification: `{ attempt }` replaces `{ getAttempt }` â€” direct value since N-describe approach fixes attempt at registration time
- unified API: both EVERY and SOME now use `({ attempt }) => {}` callback signature
- explicit context lookup: path captured at registration, used as Map key at execution â€” no implicit global `.current`
- describeStack maintained by `given`/`when` wrappers via push/pop â€” works consistently in jest and vitest
- async callback enforcement: `given`/`when` use conditional type to reject async callbacks at compile time (see research brief for details)
