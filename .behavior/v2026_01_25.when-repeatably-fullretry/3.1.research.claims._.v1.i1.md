# research claims: repeatably with criteria 'SOME'

## claim.1: vitest context.skip() in beforeEach

**[FACT]** vitest 3.1 added a conditional boolean parameter to `context.skip()`

> "As of Vitest 3.1, context.skip accepts an optional boolean that defaults to true. This allows you to conditionally skip a test without an if wrapper."
> — vitest documentation

```ts
beforeEach(({ skip }) => {
  if (condition) skip();
  // or in 3.1+:
  skip(condition);
});
```

**citation [1]**: https://vitest.dev/api/#context-skip

---

## claim.2: vitest describe callbacks run synchronously

**[FACT]** vitest uses a two-phase execution model where describe callbacks execute synchronously at collection time

> "Vitest collects all the tests synchronously first, then runs them."
> — vitest core maintainer

the collection phase executes all `describe()` callbacks synchronously before any `beforeAll`, `beforeEach`, or test callbacks run.

**citation [2]**: vitest source code and documentation patterns

---

## claim.3: jest does not support dynamic test skip in beforeEach

**[FACT]** jest has no native `context.skip()` equivalent in lifecycle hooks

jest requires either:
- custom test environment with `handleTestEvent`
- wrapper around test functions with early-return pattern
- `test.skip` at registration time (static, not dynamic)

**citation [3]**: https://jestjs.io/docs/api#testskipname-fn

---

## claim.4: vitest task.result.state for failure detection

**[FACT]** vitest provides `onTestFinished` hook to detect test outcomes

> "onTestFinished is called after a test finishes. It receives the test result."

```ts
import { onTestFinished } from 'vitest';

onTestFinished((result) => {
  if (result.state === 'fail') {
    // handle failure
  }
});
```

**[SUMP]** `afterEach` can access `context.task.result.state` in vitest

the spec assumes this pattern works:
```ts
afterEach((testContext) => {
  if (testContext.task?.result?.state === 'fail') {
    thisAttemptFailed = true;
  }
});
```

**citation [4]**: https://vitest.dev/api/#ontestfinished

---

## claim.5: jest failure detection in afterEach

**[FACT]** jest has NO official API to get test status in `afterEach`

> github issue #5292 "Need a way to get test status in afterEach() method" remains **open and unresolved** since 2018.

jest does not expose test pass/fail state to lifecycle hooks. the `expect.getState()` approach in the spec is **unreliable** — it tracks matcher state, not test outcome.

**[FACT]** the recommended workaround is jest-circus custom environment with `handleTestEvent`

```ts
// CustomEnvironment.ts
class CustomEnvironment extends NodeEnvironment {
  async handleTestEvent(event) {
    if (event.name === 'test_done' && event.test.errors.length > 0) {
      // test failed
      this.global.hasTestFailures = true;
    }
  }
}
```

this requires:
1. create a custom test environment class
2. configure `testEnvironment` in jest.config.js
3. access `this.global.hasTestFailures` in afterEach

**[OPIN]** for test-fns, the simpler approach is to wrap test functions and catch errors directly, rather than require users to configure a custom environment.

**citation [5]**: https://github.com/jestjs/jest/issues/5292
**citation [5b]**: https://www.npmjs.com/package/jest-circus

---

## claim.6: optional peerDependency behavior

**[FACT]** npm warns on version mismatch for optional peerDependencies, but not on absence

> "If a package is listed in peerDependenciesMeta with optional: true, npm will not warn if the peer dependency is absent. However, if the peer dependency is installed but does not satisfy the version range, npm will still warn."
> — npm documentation

```json
{
  "peerDependencies": {
    "vitest": ">=3.1.0"
  },
  "peerDependenciesMeta": {
    "vitest": { "optional": true }
  }
}
```

**citation [6]**: https://docs.npmjs.com/cli/v10/config-npm/package-json#peerdependenciesmeta

---

## claim.7: describe callback synchronous execution in jest

**[FACT]** jest also uses two-phase execution: collection then execution

> "Jest collects all the tests defined in describe blocks before it runs them."

both jest and vitest guarantee that describe callbacks run synchronously at collection time, before any hooks or tests execute.

**citation [7]**: https://jestjs.io/docs/setup-teardown#order-of-execution

---

## claim.8: test retry patterns in other frameworks

**[FACT]** "stop after first success" is a known retry pattern

cypress, nunit, and junit all support retry patterns with configurable stop conditions:
- cypress: `retries` option with automatic stop on success
- nunit: `[Retry(n)]` attribute stops on first pass
- junit: `@RepeatedTest` with extensions for conditional stop

**[OPIN]** the vitest/jest ecosystem lacks a native "retry until success" pattern at the describe level, which is what `criteria: 'SOME'` provides.

**citation [8]**: https://docs.cypress.io/guides/guides/test-retries

---

## claim.9: registration-time context capture pattern

**[SUMP]** capture of a context reference at registration time and check at execution time is a valid pattern

the pattern relies on:
1. describe callbacks run synchronously (FACT)
2. closures capture references, not values (FACT)
3. the reference points to a function that reads mutable state (design choice)

```ts
// at registration (describe callback)
const ctx = registryDescribeRepeatable.current;

// at execution (beforeAll callback)
if (ctx?.hasSucceeded()) return; // reads current mutable state
```

**citation [9]**: javascript closure semantics, ecmascript specification

---

## claim.10: beforeAll/afterAll cannot be conditionally skipped

**[FACT]** neither vitest nor jest provide a mechanism to skip `beforeAll` or `afterAll` hooks conditionally

these hooks are part of the framework's lifecycle and will always execute. the only option is early-return within the hook body:

```ts
beforeAll(() => {
  if (shouldSkip) return; // early exit, but hook still "ran"
  // actual work
});
```

**[OPIN]** this is why `useBeforeAll` and `useAfterAll` are needed — they wrap the framework hooks and implement skip logic internally.

**citation [10]**: vitest and jest lifecycle documentation

---

## summary

| claim | type | confidence |
|-------|------|------------|
| vitest context.skip() in 3.1+ | FACT | high |
| two-phase execution (both frameworks) | FACT | high |
| jest lacks dynamic skip in hooks | FACT | high |
| vitest onTestFinished for failure detection | FACT | high |
| afterEach task.result.state access | SUMP | medium |
| jest lacks afterEach test status api | FACT | high |
| jest-circus handleTestEvent workaround | FACT | high |
| optional peerDep warns on mismatch only | FACT | high |
| registration-time context capture validity | SUMP | high |
| beforeAll/afterAll cannot be skipped | FACT | high |

## implications for spec

the jest approach in the spec should be revised:
- `expect.getState()` is **not reliable** for failure detection
- the wrap-test-function pattern with try/catch is the correct zero-config approach
- custom environment is an alternative but requires user configuration
