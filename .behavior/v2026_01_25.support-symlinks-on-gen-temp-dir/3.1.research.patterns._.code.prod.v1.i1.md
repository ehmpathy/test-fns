# research: production codepath patterns

## pattern.1 = genTempDir orchestration [EXTEND]

the main `genTempDir` function orchestrates temp directory creation with optional fixture clone.

**file:** `src/domain.operations/genTempDir/genTempDir.ts`

```ts
// [1] signature accepts slug and optional clone
export const genTempDir = (input: { slug: string; clone?: string }): string => {
  // [2] get git root
  const gitRoot = getGitRoot();

  // [3] ensure .temp directory exists
  const baseDir = ensureTempDir({ gitRoot });

  // [4] compute unique directory name
  const dirName = computeTempDirName({ slug: input.slug });

  // [5] create the temp directory
  const tempDir = path.join(baseDir, dirName);
  fs.mkdirSync(tempDir, { recursive: true });

  // [6] trigger background prune (max once per process)
  void pruneStaleOnce({ tmpDir: baseDir });

  // [7] clone fixture if requested
  if (input?.clone) {
    // resolve clone path relative to cwd
    const clonePath = path.resolve(process.cwd(), input.clone);
    cloneFixture({ from: clonePath, to: tempDir });
  }

  return tempDir;
};
```

**relation to wish:**
- symlink option will be added alongside `clone` in the input signature [1]
- symlink creation will occur after clone (if any) [7]
- symlinks will resolve `to` paths relative to `gitRoot` [2], not `process.cwd()`

---

## pattern.2 = getGitRoot for repo-relative paths [REUSE]

the `getGitRoot` function provides portable path resolution relative to repo root.

**file:** `src/infra/isomorph.fs/getGitRoot.ts`

```ts
// [8] header declares purpose
/**
 * .what = finds the git repository root from current directory
 * .why = enables portable path resolution relative to repo root
 *
 * @throws UnexpectedCodePathError when not in a git repository
 */
export const getGitRoot = (): string => {
  // [9] uses git command for reliable root detection
  const gitRoot = execSync('git rev-parse --show-toplevel', {
    encoding: 'utf-8',
  }).trim();
```

**relation to wish:**
- symlink `to` paths will be resolved relative to `gitRoot` [9]
- this ensures tests work regardless of where `npm test` is invoked

---

## pattern.3 = cloneFixture for file operations [REUSE]

the `cloneFixture` function demonstrates file operation patterns with validation and error handle.

**file:** `src/infra/isomorph.fs/cloneFixture.ts`

```ts
// [10] header explains what and why
/**
 * .what = copies all files from source to destination recursively
 * .why = enables test directories to be pre-populated with fixture contents
 */
export const cloneFixture = (input: { from: string; to: string }): void => {
  // [11] validate source exists before operation
  if (!fs.existsSync(input.from)) {
    throw new BadRequestError(`fixture path not found: ${input.from}`, {
      from: input.from,
      to: input.to,
    });
  }

  // [12] create destination if absent
  if (!fs.existsSync(input.to)) {
    fs.mkdirSync(input.to, { recursive: true });
  }

  // [13] copy recursively with symlinks preserved
  fs.cpSync(input.from, input.to, {
    recursive: true,
    verbatimSymlinks: true,
  });
};
```

**relation to wish:**
- symlink creation will follow same validation pattern [11]
- parent directory creation pattern [12] will be reused for nested `at` paths

---

## pattern.4 = error handle with helpful-errors [REUSE]

the codebase uses `BadRequestError` for invalid user input and `UnexpectedCodePathError` for internal invariant violations.

**file:** `src/infra/isomorph.fs/cloneFixture.ts`
```ts
// [14] BadRequestError for invalid input
throw new BadRequestError(`fixture path not found: ${input.from}`, {
  from: input.from,
  to: input.to,
});
```

**file:** `src/infra/isomorph.fs/getGitRoot.ts`
```ts
// [15] UnexpectedCodePathError for internal invariant
throw new UnexpectedCodePathError('git rev-parse returned empty result', {
  cwd: process.cwd(),
});
```

**relation to wish:**
- absent symlink target → `BadRequestError` [14]
- path collision with cloned content → `BadRequestError` [14]

---

## pattern.5 = public contract exports [EXTEND]

the public API is re-exported from `src/contract/index.ts`.

**file:** `src/contract/index.ts`

```ts
// [16] re-exports genTempDir and isTempDir
export {
  genTempDir,
  isTempDir,
} from '@src/domain.operations/genTempDir/genTempDir';
```

**relation to wish:**
- no new exports needed — `genTempDir` signature extends in place

---

## pattern.6 = infra layer for filesystem operations [EXTEND]

filesystem utilities live in `src/infra/isomorph.fs/`.

**files:**
- `src/infra/isomorph.fs/cloneFixture.ts` [10-13]
- `src/infra/isomorph.fs/ensureTempDir.ts`
- `src/infra/isomorph.fs/getGitRoot.ts` [8-9]

**relation to wish:**
- new `createSymlink` utility will be added to this layer
- follows same pattern: validation → parent dir creation → fs operation

---

## pattern.7 = node:fs for filesystem operations [REUSE]

the codebase uses native `node:fs` module for all filesystem operations.

**file:** `src/infra/isomorph.fs/cloneFixture.ts`
```ts
// [17] native fs import
import * as fs from 'node:fs';

// [18] mkdirSync with recursive for parent creation
fs.mkdirSync(input.to, { recursive: true });
```

**relation to wish:**
- symlink creation will use `fs.symlinkSync(target, path)` from native `node:fs`
- parent directory creation will use `fs.mkdirSync` with `recursive: true` [18]

---

## summary

| pattern | action | reason |
|---------|--------|--------|
| genTempDir orchestration | EXTEND | add `symlink` option to input signature |
| getGitRoot | REUSE | resolve `to` paths relative to repo root |
| cloneFixture | REUSE | validation and parent-dir-creation patterns |
| helpful-errors | REUSE | BadRequestError for invalid inputs |
| contract exports | EXTEND | no change needed (signature extends in place) |
| infra/isomorph.fs | EXTEND | add createSymlink utility |
| node:fs | REUSE | use fs.symlinkSync for symlink creation |
