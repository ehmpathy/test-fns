# vision: genTempDir with git initialization

## the outcome world

### before

tests for git-aware operations required a lot of boilerplate:

```ts
const dir = genTempDir({ slug: 'my-git-test', clone: './fixtures/example' });

// manual git init ceremony
execSync('git init', { cwd: dir });
execSync('git config user.name "test"', { cwd: dir });
execSync('git config user.email "test@test.com"', { cwd: dir });
execSync('git add .', { cwd: dir });
execSync('git commit -m "initial"', { cwd: dir });
```

every test that needed a git repo repeated this dance. and often forgot a step — the `user.name`/`user.email` config would fail on ci machines with no global git config. copy-paste errors crept in. test code was noisy.

### after

```ts
const dir = genTempDir({
  slug: 'my-git-test',
  clone: './fixtures/example',
  git: true,
});
// done. git repo initialized with committed fixture content.
```

the "aha" moment: tests that verify git operations (status, diff, commits, branches) just work — no ceremony. the temp dir arrives ready for git commands.

### a day-in-the-life

vlad writes tests for a tool that detects uncommitted changes:

```ts
given('a git repo with uncommitted changes', () => {
  const dir = genTempDir({
    slug: 'uncommitted-changes-test',
    clone: './fixtures/clean-project',
    git: true, // already committed via 'fixture' commit
  });

  // make a change
  fs.writeFileSync(path.join(dir, 'README.md'), 'modified');

  when('detectUncommittedChanges is called', () => {
    then('it finds the modified file', async () => {
      const result = await detectUncommittedChanges({ cwd: dir });
      expect(result.modified).toContain('README.md');
    });
  });
});
```

no git init. no config. no initial commit. the fixture was already committed when `genTempDir` returned.

---

## user experience

### usecases

| usecase | contract | what happens |
|---------|----------|--------------|
| basic git repo | `git: true` | init + user config + 'began' commit + 'fixture' commit (if clone/symlinks exist) |
| git repo, no auto-commits | `git: { commits: { init: false } }` | init + user config only — work directory is dirty |
| git repo, init commit only | `git: { commits: { fixture: false } }` | init + user config + 'began' commit — fixture content uncommitted |
| no git | `git: undefined` (default) | current behavior, no git init |

### contract shape

```ts
export const genTempDir = (input: {
  slug: string;
  clone?: string;
  symlink?: Array<{ at: string; to: string }>;
  git?: boolean | {
    commits?: {
      init?: boolean;    // default: true — commit empty 'began' after init
      fixture?: boolean; // default: true — commit 'fixture' after clone/symlinks
    };
  };
}): string
```

### timeline

1. `git: true` passed (or `git: { ... }`)
2. `git init` executed in the temp dir
3. `git config user.name "test-fns"` executed (repo-local only)
4. `git config user.email "test-fns@test.local"` executed (repo-local only)
5. if `commits.init !== false`: empty commit with message `began`
6. clone fixture (if provided)
7. create symlinks (if provided)
8. if `commits.fixture !== false` AND (clone OR symlinks exist): `git add . && git commit -m "fixture"`
9. return path — repo is ready

### what it looks like to leverage

```ts
// test a git status helper
const dir = genTempDir({ slug: 'status-test', git: true });
fs.writeFileSync(path.join(dir, 'new-file.txt'), 'content');
const status = execSync('git status --porcelain', { cwd: dir }).toString();
expect(status).toContain('?? new-file.txt');

// test a diff helper with baseline
const dir = genTempDir({
  slug: 'diff-test',
  clone: './fixtures/baseline',
  git: true,
});
fs.appendFileSync(path.join(dir, 'config.json'), '\n// comment');
const diff = execSync('git diff', { cwd: dir }).toString();
expect(diff).toContain('+// comment');

// test branch operations
const dir = genTempDir({ slug: 'branch-test', git: true });
execSync('git checkout -b feature', { cwd: dir });
// ...verify branch behavior

// test with dirty work directory
const dir = genTempDir({
  slug: 'dirty-test',
  clone: './fixtures/example',
  git: { commits: { fixture: false } },
});
// fixture files exist but are uncommitted — perfect for tests of "stash" or "reset"
```

---

## mental model

### how users would describe this to a friend

> "genTempDir can now give you a temp directory that's already a git repo. just add `git: true` and it handles init, config, and initial commit. if you clone a fixture, that gets committed too. super handy for tests of git-aware tools."

### analogies

- like `git init` + `git commit --allow-empty -m "init"` baked into the temp dir factory
- like a "git-flavored" temp dir: same isolation, but with version control ready

### terms

| user might say | we use |
|----------------|--------|
| "make it a git repo" | `git: true` |
| "don't commit any content" | `git: { commits: { init: false } }` |
| "commit the init but not the files" | `git: { commits: { fixture: false } }` |
| "full auto" | `git: true` (default behavior when git is enabled) |

---

## evaluation

### how well does it solve the goals?

| goal | score | notes |
|------|-------|-------|
| eliminate boilerplate | excellent | one option vs 5+ lines of shell commands |
| work on ci without global git config | excellent | repo-local config means no global user.name/email needed |
| support common test patterns | excellent | clean repo, dirty repo, committed baseline all covered |
| maintain pit-of-success | excellent | defaults commit all content, explicit opts for edge cases |

### pros

- zero git ceremony in test code
- ci-safe (no dependency on global git config)
- composable with prior clone/symlink features
- explicit commit messages ('began', 'fixture') make history predictable
- opt-in — doesn't change prior behavior

### cons

- adds ~50-100ms per test if git is enabled (init + commits)
- symlinks to external paths (node_modules) may not behave as expected in git status
  - **mitigation**: symlinks are typically to paths like `node_modules` which should be gitignored anyway; users can explicitly manage `.gitignore` in their fixture

### edgecases and pit-of-success

| edgecase | behavior |
|----------|----------|
| `git: true` with no clone/symlinks | works — creates repo with just 'began' commit |
| `git: true` with clone but no content in fixture | works — 'fixture' commit is empty but valid |
| symlinks that point outside temp dir | git tracks them as symlinks; user's responsibility to handle |
| user forgets to set git config globally | no problem — repo-local config is set |
| test crashes before cleanup | normal genTempDir cleanup handles it (7-day TTL) |
| nested git repos in fixture | preserved — `fs.cpSync` with `verbatimSymlinks` handles nested `.git` |

### what's awkward?

1. **commit message customization**: users can't customize 'began' or 'fixture' messages
   - **verdict**: ok for now — these are implementation details, not user-visible history

2. **branch name**: git default branch name varies by git version
   - **mitigation**: could force `git branch -M main` but adds complexity; leave as git default for now

3. **performance**: git init + commits add latency
   - **mitigation**: only when `git: true`; most tests don't need it

---

## summary

the vision: `genTempDir({ git: true })` gives you a fully-initialized git repo with sane defaults (committed fixture content, repo-local user config) and escape hatches for edge cases (`commits.init`, `commits.fixture`). test code becomes cleaner, ci-safe, and focused on what matters — tests of git-aware operations, not setup of git.
