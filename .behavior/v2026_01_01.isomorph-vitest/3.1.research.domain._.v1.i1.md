# domain research: vitest + jest isomorphism

## wish recap

> support vitest and jest isomorphically, based on whichever is currently invoking the code that these utils are imported from
>
> it should be invisible to the user of this lib

---

## current domain analysis

### current dependencies on jest globals

the codebase currently uses these jest globals directly:

| global | file | line | usage |
|--------|------|------|-------|
| `describe` | givenWhenThen.ts | 91 | `describe(\`given: ${desc}\`, fn)` |
| `describe.only` | givenWhenThen.ts | 93 | `describe.only(\`given: ${desc}\`, fn)` |
| `describe.skip` | givenWhenThen.ts | 95 | `describe.skip(\`given: ${desc}\`, fn)` |
| `test` | givenWhenThen.ts | 117 | `test(...castToJestTestInput(...))` |
| `test.only` | givenWhenThen.ts | 119 | `test.only(...)` |
| `test.skip` | givenWhenThen.ts | 121 | `test.skip(...)` |
| `test.todo` | givenWhenThen.ts | 123 | `test.todo(...)` |
| `jest.retryTimes` | givenWhenThen.ts | 141 | `jest.retryTimes(configuration.attempts, ...)` |
| `beforeEach` | givenWhenThen.ts | 145 | `beforeEach(() => attempt++)` |
| `beforeAll` | usePrep.ts | 40 | `const register = ... beforeAll` |
| `beforeEach` | usePrep.ts | 40 | `const register = ... beforeEach` |

---

## domain objects

### TestRunner (literal)

represents which test framework is currently executing

```ts
type TestRunner = 'vitest' | 'jest' | null;
```

- **unique key**: value itself (enum-like)
- **immutable**: yes

### TestGlobals (literal)

the set of global functions available for test definition

```ts
interface TestGlobals {
  describe: DescribeFunction;
  test: TestFunction;
  beforeAll: HookFunction;
  beforeEach: HookFunction;
  afterAll: HookFunction;
  afterEach: HookFunction;
}
```

- **unique key**: derived from active runner
- **immutable**: yes (per runner invocation)

### RetryConfig (literal)

configuration for retry behavior, which differs between runners

```ts
interface RetryConfig {
  attempts: number;
  logErrorsBeforeRetry?: boolean;
}
```

---

## domain operations

### detectTestRunner

**signature**: `() => TestRunner`

**logic**:
- check `process.env.VITEST` for vitest [1]
- check `process.env.JEST_WORKER_ID` for jest [2]
- return `null` if neither detected

**citations**:
1. vitest docs: "Use `process.env.VITEST` or the mode property on `defineConfig` (which will be set to `test/benchmark` if not overridden with `--mode`) to conditionally apply different configuration. Note that like any other environment variable, `VITEST` is also exposed on `import.meta.env` in your tests." [3]
2. jest docs: "Jest sets an environment variable called `JEST_WORKER_ID` so you can check if this is set: `function areWeTestingWithJest() { return process.env.JEST_WORKER_ID !== undefined; }`" [4]

### getTestGlobals

**signature**: `() => TestGlobals`

**behavior**:
- for vitest: import from `vitest` module OR use globals if `globals: true` config [5]
- for jest: use built-in globals (always available) [6]

### setRetryTimes

**signature**: `(config: RetryConfig) => void`

**critical difference**:

| feature | jest | vitest |
|---------|------|--------|
| api | `jest.retryTimes(n, opts)` | per-test `{ retry: n }` option [7] |
| scope | file-level or per-test | config-level or per-test |
| function | `jest.retryTimes()` exists | **no `vi.retryTimes()` function** [7] |

**vitest alternative**:
```ts
// vitest config
export default defineConfig({
  test: { retry: 3 }
})

// or per-test
test('flaky', { retry: 3 }, () => {})
```

---

## api compatibility matrix

### fully compatible (same signature)

| api | jest | vitest | notes |
|-----|------|--------|-------|
| `describe(name, fn)` | ✅ | ✅ | identical |
| `describe.only` | ✅ | ✅ | identical |
| `describe.skip` | ✅ | ✅ | identical |
| `test(name, fn)` | ✅ | ✅ | identical |
| `test.only` | ✅ | ✅ | identical |
| `test.skip` | ✅ | ✅ | identical |
| `test.todo` | ✅ | ✅ | identical |
| `beforeAll(fn)` | ✅ | ✅ | vitest allows teardown return [8] |
| `beforeEach(fn)` | ✅ | ✅ | vitest allows teardown return [8] |
| `afterAll(fn)` | ✅ | ✅ | identical |
| `afterEach(fn)` | ✅ | ✅ | identical |

### incompatible (requires abstraction)

| api | jest | vitest | abstraction needed |
|-----|------|--------|-------------------|
| `jest.retryTimes()` | ✅ | ❌ | use vitest `test.retry` option |
| `jest.fn()` | ✅ | use `vi.fn()` | import from respective module |
| `jest.mock()` | ✅ | use `vi.mock()` | different factory semantics [9] |

---

## key differences discovered

### 1. retry mechanism

jest provides `jest.retryTimes()` as a runtime function [10]:
```ts
jest.retryTimes(3, { logErrorsBeforeRetry: true });
```

vitest has no equivalent function; uses config or test options [7]:
```ts
test('name', { retry: 3 }, () => {})
```

**impact**: the `then.repeatably` function at line 129-175 uses `jest.retryTimes()` which has no vitest equivalent.

### 2. globals injection

- jest: "globals are available by default" [6]
- vitest: "Jest has their globals API enabled by default. Vitest does not. You can either enable globals via the `globals` configuration setting or update your code to use imports from the vitest module instead." [5]

### 3. hook execution order

- jest: "hooks are called sequentially (one after another)"
- vitest: "By default, Vitest runs hooks in a stack" [8]

can be configured with `sequence.hooks: 'list'` in vitest.

### 4. teardown return values

vitest hooks can return teardown functions [8]:
```ts
beforeAll(() => {
  const cleanup = setup();
  return cleanup; // called after all tests
});
```

jest does not support this pattern.

---

## relationships

### treestruct of decoration

```
TestRunner
  └── TestGlobals
        ├── describe
        │     ├── describe.only
        │     └── describe.skip
        ├── test
        │     ├── test.only
        │     ├── test.skip
        │     └── test.todo
        ├── beforeAll
        ├── beforeEach
        ├── afterAll
        └── afterEach
```

### dependency flow

```
[user code]
    → imports from test-fns
    → test-fns detects runner via env vars
    → test-fns uses appropriate globals
    → transparent to user
```

---

## composition strategy

### approach: runtime detection + conditional globals

1. **detect runner** at module load time via env vars
2. **resolve globals** from appropriate source:
   - vitest: import from `vitest` if available, else use globalThis
   - jest: use globalThis (always available)
3. **abstract retry** behavior:
   - jest: use `jest.retryTimes()`
   - vitest: can't use runtime API; need different strategy
4. **export unified api** that works for both

### the retry problem

the `then.repeatably` feature uses `jest.retryTimes()` which has no vitest equivalent.

**options**:
1. skip retry feature in vitest (degraded functionality)
2. use vitest's per-test `{ retry: n }` option (requires test restructure)
3. implement manual retry loop (works in both, but different semantics)

---

## citations

[1] vitest test environment docs - https://vitest.dev/guide/environment
[2] jest environment variables docs - https://jestjs.io/docs/environment-variables
[3] vitest configuring docs - https://vitest.dev/config/
[4] phuoc.ng - check if running in jest - https://phuoc.ng/collection/1-loc/check-if-the-code-is-running-in-jest/
[5] vitest migration guide - https://vitest.dev/guide/migration.html
[6] jest globals docs - https://jestjs.io/docs/api
[7] vitest test api - https://vitest.dev/api/
[8] vitest test api (beforeAll/beforeEach) - https://vitest.dev/api/
[9] vitest migration guide (mock differences) - https://vitest.dev/guide/migration.html
[10] jest retryTimes docs - https://jestjs.io/docs/jest-object#jestretrytimesnumretries-options

---

## exact quotes from sources

### on vitest detection [3]
> "Use `process.env.VITEST` or the mode property on `defineConfig` (which will be set to `test/benchmark` if not overridden with `--mode`) to conditionally apply different configuration. Note that like any other environment variable, `VITEST` is also exposed on `import.meta.env` in your tests."

### on jest detection [4]
> "Jest sets an environment variable called `JEST_WORKER_ID` so you can check if this is set: `function areWeTestingWithJest() { return process.env.JEST_WORKER_ID !== undefined; }`"

### on globals difference [5]
> "Jest has their globals API enabled by default. Vitest does not. You can either enable globals via the `globals` configuration setting or update your code to use imports from the vitest module instead."

### on hooks difference [8]
> "beforeAll/beforeEach hooks may return teardown function in Vitest. Because of that you may need to rewrite your hooks declarations, if they return something other than undefined or null."

> "In Jest hooks are called sequentially (one after another). By default, Vitest runs hooks in a stack."

### on retry in vitest [7]
> "The `retry` option 'Will retry the test specific number of times if it fails' with a default of 0."

### on no vi.retryTimes [7]
vitest does not expose a `vi.retryTimes()` function equivalent to `jest.retryTimes()`. retry must be configured via:
- global config: `test: { retry: 3 }`
- per-test option: `test('name', { retry: 3 }, fn)`

---

## summary

### core challenge
make `test-fns` work transparently with both jest and vitest

### detection strategy
use `process.env.VITEST` and `process.env.JEST_WORKER_ID` for runtime detection

### compatible apis (easy)
`describe`, `test`, `beforeAll`, `beforeEach`, `afterAll`, `afterEach` and their modifiers (`.only`, `.skip`, `.todo`) are fully compatible

### incompatible apis (requires work)
`jest.retryTimes()` has no vitest equivalent - the `then.repeatably` feature needs rearchitecture
