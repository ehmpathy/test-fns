# blueprint: vitest + jest isomorphism

## wish recap

> support vitest and jest isomorphically, based on whichever is currently invoking the code that these utils are imported from
>
> it should be invisible to the user of this lib

---

## design principles

1. **invisible to user** - no changes required in consumer code
2. **runtime detection** - automatically detect which runner is active
3. **fail-fast** - throw clear errors if neither runner detected
4. **single source of truth** - one abstraction layer, used everywhere

---

## architecture overview

```
src/
├── contract/
│   └── index.ts                       # public exports (given, when, then, usePrep, etc.)
│
├── domain.operations/
│   ├── givenWhenThen.ts               # MODIFIED: use infra adapters
│   ├── givenWhenThen.jest.test.ts     # jest tests
│   ├── givenWhenThen.vitest.test.ts   # vitest tests
│   ├── usePrep.ts                     # MODIFIED: use infra adapters
│   ├── usePrep.jest.test.ts           # jest tests
│   ├── usePrep.vitest.test.ts         # vitest tests
│   ├── genTestUuid.ts                 # unchanged
│   └── genTestUuid.jest.test.ts       # unchanged
│
├── infra/
│   ├── isomorph.node/                 # node module system isomorphism (ESM+CJS)
│   │   ├── getRequire.ts              # NEW: isomorphic require for ESM+CJS
│   │   ├── getRequire.jest.test.ts
│   │   └── getRequire.vitest.test.ts
│   │
│   └── isomorph.test/                 # test runner isomorphism (jest+vitest)
│       ├── detectTestRunner.ts        # NEW: runtime detection
│       ├── detectTestRunner.jest.test.ts
│       ├── detectTestRunner.vitest.test.ts
│       ├── getTestGlobals.ts          # NEW: dynamic require from vitest/@jest/globals
│       ├── getTestGlobals.jest.test.ts
│       ├── getTestGlobals.vitest.test.ts
│       ├── runTest.ts                 # NEW: unified test wrapper with retry
│       ├── runTest.jest.test.ts
│       └── runTest.vitest.test.ts
│
└── index.ts                           # re-export from contract/
```

### layer responsibilities

| layer                     | purpose                                             |
| ------------------------- | --------------------------------------------------- |
| `contract/`               | public sdk exports - what consumers import          |
| `domain.operations/`      | test helpers (given/when/then, usePrep)             |
| `infra/isomorph.node/`    | node module system isomorphism (ESM+CJS)            |
| `infra/isomorph.test/`    | test runner isomorphism (jest+vitest)               |

---

## step 1: detectTestRunner

### file: `src/infra/isomorph.test/detectTestRunner.ts`

```ts
/**
 * .what = detects which test runner is currently executing
 * .why = enables isomorphic behavior between vitest and jest
 */
export type TestRunner = 'vitest' | 'jest';

export const detectTestRunner = (): TestRunner => {
  // check for vitest first (more specific)
  // ref: https://vitest.dev/config/
  // > "Use `process.env.VITEST` ... to conditionally apply different configuration"
  if (process.env.VITEST !== undefined) return 'vitest';

  // check for jest
  // ref: https://jestjs.io/docs/environment-variables
  // > "JEST_WORKER_ID ... Each worker process is assigned a unique id"
  if (process.env.JEST_WORKER_ID !== undefined) return 'jest';

  // fail fast if neither detected
  throw new UnexpectedCodePathError(
    'detectTestRunner: no test runner detected. expected VITEST or JEST_WORKER_ID env var',
    { env: { VITEST: process.env.VITEST, JEST_WORKER_ID: process.env.JEST_WORKER_ID } }
  );
};

// cached result for performance
let runnerCached: TestRunner | undefined;
export const getTestRunner = (): TestRunner => {
  if (runnerCached === undefined) runnerCached = detectTestRunner();
  return runnerCached;
};
```

### test coverage

| case                    | test                                               |
| ----------------------- | -------------------------------------------------- |
| vitest detected         | mock `process.env.VITEST`, expect `'vitest'`       |
| jest detected           | mock `process.env.JEST_WORKER_ID`, expect `'jest'` |
| neither detected        | mock neither, expect `UnexpectedCodePathError`     |
| vitest takes precedence | mock both, expect `'vitest'`                       |

---

## step 2: getTestGlobals (synchronous require)

### file: `src/infra/isomorph.test/getTestGlobals.ts`

```ts
import type { describe, test, beforeAll, beforeEach, afterAll, afterEach } from 'vitest';

import { UnexpectedCodePathError } from 'helpful-errors';

import { getTestRunner } from '@src/infra/isomorph.test/detectTestRunner';
import { req } from '@src/infra/isomorph.node/getRequire';

/**
 * .what = provides unified access to test functions
 * .why = abstracts away differences between jest and vitest modules
 */
export interface TestGlobals {
  describe: typeof describe;
  test: typeof test;
  beforeAll: typeof beforeAll;
  beforeEach: typeof beforeEach;
  afterAll: typeof afterAll;
  afterEach: typeof afterEach;
}

// cached result
let cachedGlobals: TestGlobals | undefined;

/**
 * .what = synchronously requires test functions from the active runner
 * .why = test registration must be synchronous (describe/test called at module load)
 */
export const getTestGlobals = (): TestGlobals => {
  if (cachedGlobals) return cachedGlobals;

  const runner = getTestRunner();

  if (runner === 'vitest') {
    const vitest = req('vitest');
    cachedGlobals = {
      describe: vitest.describe,
      test: vitest.test,
      beforeAll: vitest.beforeAll,
      beforeEach: vitest.beforeEach,
      afterAll: vitest.afterAll,
      afterEach: vitest.afterEach,
    };
    return cachedGlobals;
  }

  if (runner === 'jest') {
    const jestGlobals = req('@jest/globals');
    cachedGlobals = {
      describe: jestGlobals.describe,
      test: jestGlobals.test,
      beforeAll: jestGlobals.beforeAll,
      beforeEach: jestGlobals.beforeEach,
      afterAll: jestGlobals.afterAll,
      afterEach: jestGlobals.afterEach,
    };
    return cachedGlobals;
  }

  throw new UnexpectedCodePathError('unknown runner', { runner });
};

/**
 * .what = cached globals accessor
 * .why = avoids repeated require() calls
 */
export const globals = (): TestGlobals => {
  if (!cachedGlobals) cachedGlobals = getTestGlobals();
  return cachedGlobals;
};
```

### why synchronous?

test registration happens at module evaluation time:

```ts
// this runs synchronously when file is loaded
describe('my test', () => {
  test('something', () => {});
});
```

async won't work - by the time the promise resolves, the test collection phase is already complete.

### why require() instead of import()?

- `require()` is synchronous
- `import()` is async (returns Promise)
- test frameworks need sync registration

### isomorphic require adapter

**file: `src/infra/isomorph.node/getRequire.ts`**

```ts
import { createRequire } from 'node:module';

/**
 * .what = provides a require function that works in both ESM and CJS
 * .why = ESM doesn't have global require, CJS doesn't have import.meta.url
 *
 * .note = the import.meta.url branch only executes in ESM context where it's valid.
 *         if require exists, we return early before reaching import.meta.url.
 */
const getRequire = (): NodeRequire => {
  // CJS context: require is available globally
  if (typeof require === 'function') return require;

  // ESM context: use createRequire with import.meta.url
  return createRequire(import.meta.url);
};

export const req = getRequire();
```

### why this works

- **CJS context**: `typeof require === 'function'` is true → early return → `import.meta.url` never evaluated
- **ESM context**: `typeof require === 'function'` is false → reaches `import.meta.url` → valid in ESM

no build tools needed — the early return guards the ESM-only syntax.

### test coverage

| case                    | test                                 |
| ----------------------- | ------------------------------------ |
| vitest runner detected  | requires from `vitest` module        |
| jest runner detected    | requires from `@jest/globals` module |
| cached after first call | second call returns cached instance  |

---

## step 3: unified test wrapper with retry support

### the challenge

- jest: `jest.retryTimes(n, opts)` - file-level function before `test()`
- vitest: `test('name', { retry: n }, fn)` - per-test options object

### solution: abstract the test call itself

instead of abstracting just `retryTimes`, we abstract the entire `test()` call to handle retry differently per runner.

### file: `src/infra/isomorph.test/runTest.ts`

```ts
/**
 * .what = unified test execution with retry support
 * .why = jest and vitest have different retry mechanisms
 */
export interface TestOptions {
  retry?: number;
}

export const runTest = (
  input: {
    name: string;
    fn: (() => void) | (() => Promise<void>);
    options?: TestOptions;
  }
): void => {
  const runner = getTestRunner();
  const { name, fn, options } = input;

  if (runner === 'vitest' && options?.retry) {
    // vitest: pass retry as per-test option
    test(name, { retry: options.retry }, fn);
    return;
  }

  if (runner === 'jest' && options?.retry) {
    // jest: use jest.retryTimes before test call
    jest.retryTimes(options.retry, { logErrorsBeforeRetry: true });
    test(name, fn);
    return;
  }

  // no retry: standard test call
  test(name, fn);
};

// same pattern for test.only, test.skip, etc.
export const runTestOnly = (input: Parameters<typeof runTest>[0]): void => {
  const runner = getTestRunner();
  const { name, fn, options } = input;

  if (runner === 'vitest' && options?.retry) {
    test.only(name, { retry: options.retry }, fn);
    return;
  }

  if (runner === 'jest' && options?.retry) {
    jest.retryTimes(options.retry, { logErrorsBeforeRetry: true });
    test.only(name, fn);
    return;
  }

  test.only(name, fn);
};
```

### key insight

vitest's per-test `{ retry: n }` option is the equivalent of jest's `jest.retryTimes(n)`.

| runner | syntax                                 |
| ------ | -------------------------------------- |
| jest   | `jest.retryTimes(3); test('name', fn)` |
| vitest | `test('name', { retry: 3 }, fn)`       |

both achieve the same result: retry the test up to N times if it fails.

### test coverage

| case                         | test                                 |
| ---------------------------- | ------------------------------------ |
| runTest without retry        | both runners call `test(name, fn)`   |
| runTest with retry in jest   | calls `jest.retryTimes` then `test`  |
| runTest with retry in vitest | calls `test` with `{ retry }` option |

---

## step 4: modify givenWhenThen.ts

### changes required

1. import globals from abstraction layer
2. use `runTest` with retry option for `then.repeatably` criteria='SOME'

```ts
// before
jest.retryTimes(configuration.attempts, { logErrorsBeforeRetry: true });
// ...
if (input.length === 2) then(input[0], () => input[1]({ attempt }));

// after
import { globals } from '@src/infra/isomorph.test/getTestGlobals';
import { runTest } from '@src/infra/isomorph.test/runTest';

const { describe, beforeEach } = globals();

// in then.repeatably:
if (configuration.criteria === 'SOME') {
  // track attempts
  let attempt = 0;
  beforeEach(() => attempt++);

  // use runTest with retry option - works in both jest and vitest
  const testName = `then: ${input[0]}`;
  const testFn = () => input[input.length - 1]({ attempt });

  runTest({
    name: testName,
    fn: testFn,
    options: { retry: configuration.attempts },
  });
  return;
}
```

### the key change

instead of:
- calling `jest.retryTimes()` (jest-only)
- then calling `test()` normally

we now:
- call `runTest()` which internally handles retry per-runner
- jest: calls `jest.retryTimes()` then `test()`
- vitest: calls `test()` with `{ retry }` option

### test coverage additions

| case                                 | test                       |
| ------------------------------------ | -------------------------- |
| given/when/then work in jest         | existing tests pass        |
| given/when/then work in vitest       | new tests in vitest runner |
| then.repeatably EVERY works in both  | test in both runners       |
| then.repeatably SOME works in jest   | test in jest ✅             |
| then.repeatably SOME works in vitest | test in vitest ✅           |

---

## step 5: modify usePrep.ts

### changes required

1. import `beforeAll`/`beforeEach` from abstraction layer

```ts
// before
const register = options.mode === 'beforeEach' ? beforeEach : beforeAll;

// after
import { globals } from '@src/infra/isomorph.test/getTestGlobals';

const { beforeAll, beforeEach } = globals();
const register = options.mode === 'beforeEach' ? beforeEach : beforeAll;
```

### test coverage

existing tests should continue to pass in both runners.

---

## step 6: test infrastructure

### jest tests

location: `src/**/*.jest.test.ts`

#### file: `jest.config.ts` update

```ts
export default {
  testMatch: ['**/*.jest.test.ts'],
  // ... existing config
};
```

run via: `npm run test:jest`

### vitest tests

location: `src/**/*.vitest.test.ts`

#### file: `vitest.config.ts`

```ts
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    include: ['src/**/*.vitest.test.ts'],
  },
});
```

note: no `globals: true` needed - we dynamically import from `vitest` module.

run via: `npm run test:vitest`

#### file: `package.json` additions

```json
{
  "scripts": {
    "test:jest": "jest",
    "test:vitest": "vitest run",
    "test:unit": "npm run test:jest && npm run test:vitest"
  },
  "devDependencies": {
    "vitest": "^2.0.0",
    "@jest/globals": "^29.0.0"
  },
  "peerDependencies": {
    "vitest": ">=1.0.0",
    "jest": ">=29.0.0"
  },
  "peerDependenciesMeta": {
    "vitest": { "optional": true },
    "jest": { "optional": true }
  }
}
```

---

## step 7: acceptance tests

### blackbox behaviors to verify

| behavior                           | jest | vitest |
| ---------------------------------- | ---- | ------ |
| `given()` creates describe block   | ✅    | ✅      |
| `when()` creates describe block    | ✅    | ✅      |
| `then()` creates test block        | ✅    | ✅      |
| `.only` modifier works             | ✅    | ✅      |
| `.skip` modifier works             | ✅    | ✅      |
| `.todo` modifier works             | ✅    | ✅      |
| `.skipIf` modifier works           | ✅    | ✅      |
| `.runIf` modifier works            | ✅    | ✅      |
| `usePrep` mode='beforeAll' works   | ✅    | ✅      |
| `usePrep` mode='beforeEach' works  | ✅    | ✅      |
| `then.repeatably` criteria='EVERY' | ✅    | ✅      |
| `then.repeatably` criteria='SOME'  | ✅    | ✅      |

### acceptance test structure

```ts
// src/__acceptance__/isomorphism.jest.acceptance.test.ts
describe('isomorphic behavior', () => {
  given('test-fns imported in jest', () => {
    then('all exports work correctly', () => {
      // verify each export
    });

    then.repeatably({ attempts: 3, criteria: 'SOME' })(
      'then.repeatably SOME retries until success',
      ({ attempt }) => {
        expect(attempt).toBeGreaterThanOrEqual(3);
      },
    );
  });
});

// src/__acceptance__/isomorphism.vitest.acceptance.test.ts
describe('isomorphic behavior', () => {
  given('test-fns imported in vitest', () => {
    then('all exports work correctly', () => {
      // verify each export
    });

    then.repeatably({ attempts: 3, criteria: 'SOME' })(
      'then.repeatably SOME retries until success',
      ({ attempt }) => {
        expect(attempt).toBeGreaterThanOrEqual(3);
      },
    );
  });
});
```

---

## implementation order

### phase 1: infrastructure layer

1. [ ] create `src/infra/isomorph.node/getRequire.ts`
2. [ ] create `src/infra/isomorph.node/getRequire.jest.test.ts`
3. [ ] create `src/infra/isomorph.test/detectTestRunner.ts`
4. [ ] create `src/infra/isomorph.test/detectTestRunner.jest.test.ts`
5. [ ] create `src/infra/isomorph.test/getTestGlobals.ts`
6. [ ] create `src/infra/isomorph.test/getTestGlobals.jest.test.ts`
7. [ ] create `src/infra/isomorph.test/runTest.ts`
8. [ ] create `src/infra/isomorph.test/runTest.jest.test.ts`

### phase 2: domain operations + contract

9. [ ] move existing files to `src/domain.operations/`
10. [ ] rename `*.test.ts` to `*.jest.test.ts`
11. [ ] modify `src/domain.operations/givenWhenThen.ts` to use infra
12. [ ] modify `src/domain.operations/usePrep.ts` to use infra
13. [ ] create `src/contract/index.ts` with public exports
14. [ ] update `src/index.ts` to re-export from contract
15. [ ] verify existing jest tests still pass

### phase 3: vitest infrastructure

16. [ ] add `vitest` to devDependencies
17. [ ] add `@jest/globals` to devDependencies (for explicit imports)
18. [ ] create `vitest.config.ts` with `include: ['**/*.vitest.test.ts']`
19. [ ] update `jest.config.ts` with `testMatch: ['**/*.jest.test.ts']`
20. [ ] add npm scripts: `test:jest`, `test:vitest`

### phase 4: vitest tests

21. [ ] create `src/infra/isomorph.node/getRequire.vitest.test.ts`
22. [ ] create `src/infra/isomorph.test/detectTestRunner.vitest.test.ts`
23. [ ] create `src/infra/isomorph.test/getTestGlobals.vitest.test.ts`
24. [ ] create `src/infra/isomorph.test/runTest.vitest.test.ts`
25. [ ] create `src/domain.operations/givenWhenThen.vitest.test.ts`
26. [ ] create `src/domain.operations/usePrep.vitest.test.ts`

### phase 5: acceptance tests

27. [ ] create acceptance tests for jest runner
28. [ ] create acceptance tests for vitest runner

### phase 6: documentation

29. [ ] update README with vitest compatibility notes

---

## test matrix

| layer       | subdomain      | file                                   | runner |
| ----------- | -------------- | -------------------------------------- | ------ |
| unit        | isomorph.node  | getRequire.jest.test.ts                | jest   |
| unit        | isomorph.node  | getRequire.vitest.test.ts              | vitest |
| unit        | isomorph.test  | detectTestRunner.jest.test.ts          | jest   |
| unit        | isomorph.test  | detectTestRunner.vitest.test.ts        | vitest |
| unit        | isomorph.test  | getTestGlobals.jest.test.ts            | jest   |
| unit        | isomorph.test  | getTestGlobals.vitest.test.ts          | vitest |
| unit        | isomorph.test  | runTest.jest.test.ts                   | jest   |
| unit        | isomorph.test  | runTest.vitest.test.ts                 | vitest |
| integration | domain.ops     | givenWhenThen.jest.test.ts             | jest   |
| integration | domain.ops     | givenWhenThen.vitest.test.ts           | vitest |
| integration | domain.ops     | usePrep.jest.test.ts                   | jest   |
| integration | domain.ops     | usePrep.vitest.test.ts                 | vitest |
| acceptance  | contract       | isomorphism.jest.acceptance.test.ts    | jest   |
| acceptance  | contract       | isomorphism.vitest.acceptance.test.ts  | vitest |

---

## risks and mitigations

### risk 1: dynamic import timing

**mitigation**: initialize globals at module load time via `initTestGlobals()`. the promise resolves before any test runs.

### risk 2: retry semantics differ slightly

**mitigation**: both runners now use per-test retry (vitest natively, jest via `jest.retryTimes` before `test()`). behavior is functionally identical.

### risk 3: different hook execution order

**mitigation**: document that vitest uses stack order by default; recommend `sequence.hooks: 'list'` for jest-like behavior

### risk 4: teardown return value differences

**mitigation**: usePrep doesn't return teardown; no impact expected

---

## success criteria

1. ✅ existing jest tests pass unchanged
2. ✅ new vitest tests pass
3. ✅ user code requires zero changes
4. ✅ detection is automatic and invisible
5. ✅ clear error messages for unsupported features
6. ✅ documentation covers limitations

---

## decisions made

1. **dynamic imports, not globals**
   - always dynamically import from `vitest` or `@jest/globals`
   - no `globals: true` config needed in vitest
   - cleaner, more explicit

2. **jest and vitest as peerDependencies**
   - both are optional peerDependencies
   - allows consumers to use either runner without forcing both
   - types for whichever runner is used will be available
