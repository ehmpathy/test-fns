# usecase.1 = generate an ephemeral test directory

given('a test that needs a temporary directory')
  when('genTempDir is called with no options')
    then('returns an absolute path to a new directory')
      sothat('callers can immediately write files to the returned path')
    then('the directory exists on the filesystem')
    then('the directory is empty')
    then('the directory path contains a timestamp prefix')
      sothat('age-based prune can be performed without stat calls')

  when('genTempDir is called multiple times in quick succession')
    then('each call returns a unique directory path')
      sothat('parallel tests do not collide')


# usecase.2 = generate a test directory from a fixture

given('a test that needs a pre-populated directory')
  when('genTempDir is called with { clone: "path/to/fixture" }')
    then('returns an absolute path to a new directory')
    then('the directory contains a copy of all files from the fixture path')
      sothat('tests can modify fixture contents without effect on the source')
    then('the original fixture directory is unchanged')

  when('genTempDir is called with a clone path that does not exist')
    then('throws a clear error that indicates the fixture path was not found')
      sothat('users can quickly diagnose misconfigured test setups')


# usecase.3 = automatic cleanup of stale test directories

given('test directories that were created over 1 hour ago')
  when('genTempDir is called for the first time in a process')
    then('stale directories are pruned in the background')
      sothat('disk space is reclaimed without user intervention')
    then('the new directory is still created and returned promptly')
      sothat('prune does not block test execution')

given('test directories that were created less than 1 hour ago')
  when('genTempDir is called')
    then('recent directories are not pruned')
      sothat('concurrent tests are not disrupted')

given('genTempDir has already been called once in this process')
  when('genTempDir is called again')
    then('prune is skipped')
      sothat('redundant filesystem scans are avoided')
    then('the new directory is still created normally')
      sothat('throttle only affects prune, not directory creation')


# usecase.4 = cross-platform portability

given('a macos machine')
  when('genTempDir is called')
    then('the directory is created successfully')
    then('the directory path is within the git repository')
      sothat('no os-specific temp dir assumptions are required')

given('an ubuntu linux machine')
  when('genTempDir is called')
    then('the directory is created successfully')
    then('the directory path is within the git repository')
      sothat('no reliance on XDG_RUNTIME_DIR or /tmp auto-prune')


# usecase.5 = discoverability and documentation

given('a developer who discovers genTempDir for the first time')
  when('they view the function in their ide')
    then('jsdoc comments explain the purpose and usage')
    then('jsdoc comments show example invocations')
      sothat('developers can use the function without need to read external docs')

given('a developer who reads the test-fns readme')
  when('they look for temp directory utilities')
    then('genTempDir is documented with clear examples')
    then('the auto-prune behavior is explained')
    then('the clone option is documented')
      sothat('all capabilities are discoverable')


# boundary.1 = edge cases

given('the .tmp directory does not yet exist at gitroot')
  when('genTempDir is called')
    then('the .tmp directory is created automatically')
    then('a readme.md is placed in .tmp that explains the ttl policy')
      sothat('humans who discover the directory understand its purpose')

given('a fixture directory with nested subdirectories')
  when('genTempDir is called with { clone: "path/to/nested/fixture" }')
    then('all nested files and directories are copied recursively')

given('a fixture directory with symlinks')
  when('genTempDir is called with { clone: "path/to/fixture-with-symlinks" }')
    then('symlinks are preserved as symlinks in the copy')
      sothat('test scenarios that involve symlinks work correctly')
