# blueprint: genTempDir race condition fix

## summary

fix TOCTOU (time-of-check-time-of-use) race condition in `genIsolatedTempInfra` where parallel workers calling `genTempDir` simultaneously can fail with `EEXIST` when creating the symlink.

## root cause

```
.error =
EEXIST: file already exists, symlink '/tmp/test-fns/khlone/.temp' -> '/home/runner/work/khlone/khlone/.temp/genTempDir.symlink'
```

race timeline:
1. worker A: `fs.existsSync(pathSymlink)` → false
2. worker B: `fs.existsSync(pathSymlink)` → false
3. worker A: `fs.symlinkSync(pathPhysical, pathSymlink)` → success
4. worker B: `fs.symlinkSync(pathPhysical, pathSymlink)` → EEXIST error

the code at `genIsolatedTempInfra.ts:95-97`:
```ts
} else {
  // symlink absent, create it
  fs.symlinkSync(pathPhysical, pathSymlink);
}
```

## solution approach

make symlink creation idempotent by:
1. attempt to create symlink
2. if EEXIST error, verify symlink points to expected target
3. if target matches, succeed (idempotent)
4. if target differs, update symlink to correct target

this eliminates the race window entirely — the first worker to create wins, subsequent workers verify and succeed.

---

## filediffs treestruct

```
src/
└── infra/
    └── isomorph.fs/
        ├── [~] genIsolatedTempInfra.ts              # add idempotent symlink creation
        └── [~] genIsolatedTempInfra.integration.jest.test.ts  # add race condition test
```

**legend:**
- `[+] create` — file to create
- `[~] update` — file to update
- `[-] delete` — file to delete

---

## codepaths treestruct

```
genIsolatedTempInfra.ts
├── [○] validate /tmp/ extant
├── [○] compute paths (pathPhysical, pathGitRootTemp, pathSymlink)
├── [○] ensure @gitroot/.temp/ dir extant
├── [○] ensure physical dir extant
├── [○] write readme.md if absent
├── [○] write .gitignore if absent
├── [~] ensure symlink at @gitroot/.temp/genTempDir.symlink
│   ├── [○] if symlink extant and is symlink
│   │   ├── [○] verify target matches
│   │   └── [○] update if stale
│   ├── [○] if directory extant
│   │   └── [○] remove and create symlink
│   ├── [○] if file extant
│   │   └── [○] remove and create symlink
│   └── [~] if absent → create symlink idempotently
│       ├── [+] try: fs.symlinkSync()
│       └── [+] catch EEXIST: verify target, update if needed
└── [○] return { pathPhysical, pathSymlink }
```

**legend:**
- `[+]` create — codepath to create
- `[~]` update — codepath to update
- `[○]` retain — codepath to retain
- `[-]` delete — codepath to delete

---

## contracts

### genIsolatedTempInfra (updated)

```ts
/**
 * .what = ensures the isolated temp infrastructure is extant
 * .why = creates physical storage in /tmp/ with symlink at gitroot for discoverability
 *
 * .note = symlink creation is idempotent — safe to call from parallel workers
 *
 * @throws UnexpectedCodePathError if /tmp/ does not extant
 */
export const genIsolatedTempInfra = (input: {
  gitRoot: string;
}): { pathPhysical: string; pathSymlink: string }
```

contract unchanged — only internal implementation becomes race-safe.

---

## implementation details

### change: idempotent symlink creation

replace:
```ts
} else {
  // symlink absent, create it
  fs.symlinkSync(pathPhysical, pathSymlink);
}
```

with:
```ts
} else {
  // symlink absent, create it idempotently (race-safe)
  try {
    fs.symlinkSync(pathPhysical, pathSymlink);
  } catch (error) {
    // handle race: another worker created symlink between check and create
    if (!(error instanceof Error)) throw error;
    if (!error.message.includes('EEXIST')) throw error;

    // verify symlink was created by another worker with expected target
    const stat = fs.lstatSync(pathSymlink);
    if (!stat.isSymbolicLink()) {
      // not a symlink (file or dir) — remove and retry
      fs.rmSync(pathSymlink, { recursive: true, force: true });
      fs.symlinkSync(pathPhysical, pathSymlink);
    } else {
      // is a symlink — verify target
      const currentTarget = fs.readlinkSync(pathSymlink);
      if (currentTarget !== pathPhysical) {
        // stale target — update
        fs.unlinkSync(pathSymlink);
        fs.symlinkSync(pathPhysical, pathSymlink);
      }
      // else: correct symlink already extant — idempotent success
    }
  }
}
```

### rationale

- **try-first**: attempt creation optimistically (fast path for first caller)
- **catch EEXIST**: handle race without check-then-act pattern
- **verify target**: ensure symlink points to correct location
- **update if stale**: handle edge case where another process created symlink with different target

---

## test coverage

### integration test: race condition

```ts
given('[case5] multiple parallel calls to genIsolatedTempInfra', () => {
  // setup: remove symlink to simulate first-time setup
  beforeAll(() => {
    if (fs.existsSync(pathSymlinkExpected)) {
      const stat = fs.lstatSync(pathSymlinkExpected);
      if (stat.isSymbolicLink()) {
        fs.unlinkSync(pathSymlinkExpected);
      } else if (stat.isDirectory()) {
        fs.rmSync(pathSymlinkExpected, { recursive: true, force: true });
      }
    }
  });

  when('[t0] 10 concurrent calls are made', () => {
    const results = useThen('all calls succeed', async () => {
      const promises = Array.from({ length: 10 }, () =>
        Promise.resolve(genIsolatedTempInfra({ gitRoot }))
      );
      return Promise.all(promises);
    });

    then('all calls return same paths', () => {
      for (const result of results) {
        expect(result.pathPhysical).toEqual(pathPhysicalExpected);
        expect(result.pathSymlink).toEqual(pathSymlinkExpected);
      }
    });

    then('symlink is extant and points to correct target', () => {
      expect(fs.lstatSync(pathSymlinkExpected).isSymbolicLink()).toBe(true);
      expect(fs.readlinkSync(pathSymlinkExpected)).toEqual(pathPhysicalExpected);
    });
  });
});
```

---

## blackbox criteria satisfied

given parallel workers call genTempDir simultaneously
  when both workers attempt to create symlink infrastructure
    then both workers succeed idempotently
      sothat CI shards can run tests in parallel without coordination

---

## risk assessment

| risk | likelihood | impact | mitigation |
|------|------------|--------|------------|
| EEXIST not caught | low | low | explicit error code check |
| stale symlink | low | low | verify target and update |
| file instead of symlink | low | low | remove and recreate |

---

## implementation sequence

1. update `genIsolatedTempInfra.ts` with idempotent symlink creation
2. add integration test for parallel calls
3. verify prior tests pass
4. run test suite to confirm fix
