# research: test code patterns

## summary

this document catalogs test codepath patterns in the test-fns repo relevant to the slowtest reporter feature. each pattern is marked as [REUSE], [EXTEND], or [REPLACE].

---

## 1. test file organization

### [REUSE] file suffix conventions

test files follow consistent suffix conventions for different test types.

**observed patterns:**
- unit tests: `*.jest.test.ts` or `*.vitest.test.ts`
- integration tests: `*.integration.jest.test.ts`
- acceptance tests: `*.acceptance.jest.test.ts`
- bdd-style vitest: `*.vitest.bdd.test.ts`
- globals-based vitest: `*.vitest.globals.test.ts`
- repeatably tests: `*.repeatably.jest.test.ts`

**relation to wish:** slowtest reporter tests will follow the same conventions:
- `slowtestReporter.jest.test.ts` (unit tests for jest reporter)
- `slowtestReporter.vitest.test.ts` (unit tests for vitest reporter)
- `slowtestReporter.integration.jest.test.ts` (integration with actual test runs)
- `slowtestReporter.acceptance.jest.test.ts` (end-to-end scenarios)

---

## 2. given/when/then hierarchy

### [REUSE] basic bdd structure

tests use `given`/`when`/`then` from test-fns for hierarchical organization.

**file:** `src/domain.operations/givenWhenThen.jest.test.ts` [1]

```typescript
describe('doesPlantNeedWater', () => {
  given('a plant', () => {
    when('the plant doesnt have enough water', () => {
      const plant: Plant = {
        id: 7,
        hydration: 'DRY',
      };
      then('it should return true', () => {
        expect(doesPlantNeedWater(plant)).toEqual(true);
      });
    });
  });
});
```

**relation to wish:** reporter tests will use same bdd structure to test reporter behavior.

### [REUSE] skip and todo modifiers

tests can use `.skip` and `.todo` modifiers for incomplete tests.

**file:** `src/domain.operations/givenWhenThen.jest.test.ts` [2]

```typescript
then.skip('it should be possible to skip a test too', () => {
  throw new Error('should have been skipped');
});
then.todo('it should be possible to todo a test too', () => {
  throw new Error('should have been ignored');
});
```

**relation to wish:** useful for incremental development of reporter tests.

### [REUSE] conditional execution with skipIf/runIf

tests can conditionally skip based on runtime conditions.

**file:** `src/domain.operations/givenWhenThen.jest.test.ts` [3]

```typescript
given.runIf(false)('runIf=false', () => {
  then('should be skipped', () => {
    throw new Error('should not have been run');
  });
});
then.skipIf(true)('this should be skipped', () => {
  throw new Error('should not have been run');
});
```

**relation to wish:** may use to skip reporter tests that require specific runner (e.g., vitest-only tests).

---

## 3. useBeforeAll/useBeforeEach pattern

### [REUSE] shared setup with useBeforeAll

`useBeforeAll` runs once before all tests in a block, returns proxy for deferred access.

**file:** `src/domain.operations/usePrep.jest.test.ts` [4]

```typescript
given('a setup function that returns a test object', () => {
  const setup = async () => {
    callCount++;
    return { value: `hello-${callCount}` };
  };

  describe('mode: beforeAll', () => {
    when('registered with usePrep', () => {
      const result = usePrep(setup, { mode: 'beforeAll' });

      then('value should be resolved once before all tests', async () => {
        expect(result.value).toBeDefined();
        expect(result.value).toMatch(/hello-1/);
      });

      then('subsequent tests still see the same value', async () => {
        expect(result.value).toBe(`hello-1`);
      });
    });
  });
});
```

**relation to wish:** reporter integration tests will use `useBeforeAll` for expensive setup (e.g., run a test suite and capture output).

### [REUSE] fresh setup with useBeforeEach

`useBeforeEach` runs before each test for fresh state.

**file:** `src/domain.operations/usePrep.jest.test.ts` [5]

```typescript
describe('mode: beforeEach', () => {
  when('registered with usePrep', () => {
    const capturedValues: string[] = [];
    const result = usePrep(setup, { mode: 'beforeEach' });

    then('each test gets a fresh value', async () => {
      capturedValues.push(result.value);
      expect(result.value).toMatch(/hello-\d+/);
    });

    then('value is recomputed between tests', async () => {
      capturedValues.push(result.value);
      expect(new Set(capturedValues).size).toBeGreaterThan(1);
    });
  });
});
```

**relation to wish:** useful when tests need isolated reporter instances.

---

## 4. useThen pattern

### [REUSE] capture async operation results

`useThen` captures operation result for assertions in subsequent blocks.

**file:** `src/domain.operations/useThen.jest.test.ts` [6]

```typescript
given('useThen is used to capture an operation result', () => {
  when('the operation returns an object', () => {
    const result = useThen('operation succeeds', async () => {
      return { status: 'success', data: { id: 123 } };
    });

    then('return value is accessible in subsequent then blocks', () => {
      expect(result.status).toEqual('success');
    });

    then('nested properties are accessible', () => {
      expect(result.data.id).toEqual(123);
    });
  });
});
```

**relation to wish:** reporter tests will use `useThen` to capture reporter output and assert on multiple properties without re-run.

### [REUSE] chained operations

multiple `useThen` calls can reference each other.

**file:** `src/domain.operations/useThen.jest.test.ts` [7]

```typescript
given('multiple useThen calls in same when block', () => {
  when('operations are chained', () => {
    const first = useThen('first operation', async () => {
      return { step: 1 };
    });

    const second = useThen('second operation', async () => {
      return { step: 2, prevStep: first.step };
    });

    then('first result is accessible', () => {
      expect(first.step).toEqual(1);
    });

    then('second result references first', () => {
      expect(second.step).toEqual(2);
      expect(second.prevStep).toEqual(1);
    });
  });
});
```

**relation to wish:** useful for tests that need to run reporter, then run again with baseline comparison.

---

## 5. useWhen pattern

### [REUSE] share results across peer when blocks

`useWhen` enables sequential operations where later blocks reference earlier results.

**file:** `src/domain.operations/useWhen.jest.test.ts` [8]

```typescript
given('idempotency verification pattern', () => {
  when('[t0] before any changes', () => {
    then('initial state is confirmed', () => {
      expect(true).toEqual(true);
    });
  });

  const responseFirst = useWhen('[t1] operation is called', () => {
    const response = useThen('operation succeeds', async () => {
      return { id: 123, status: 'created', affected: ['resource-a'] };
    });

    then('response has expected id', () => {
      expect(response.id).toEqual(123);
    });

    return response;
  });

  when('[t2] operation is repeated', () => {
    const responseSecond = useThen('operation still succeeds', async () => {
      return { id: 123, status: 'created', affected: ['resource-a'] };
    });

    then('response is idempotent', () => {
      expect(responseSecond.id).toEqual(responseFirst.id);
    });
  });
});
```

**relation to wish:** reporter tests can use this for baseline comparison scenarios (run once, save baseline, run again, compare delta).

---

## 6. case/time label convention

### [REUSE] [caseN] for given blocks

given blocks use `[case1]`, `[case2]`, etc. for major use cases.

**file:** `src/domain.operations/genTempDir/genTempDir.acceptance.jest.test.ts` [9]

```typescript
// usecase.1: generate an ephemeral temp directory
given('[case1] a test that needs a temporary directory', () => {
  when('[t0] genTempDir is called with a slug', () => {
    then('returns an absolute path to a new directory', () => { ... });
  });
});

// usecase.2: generate a temp directory from a fixture
given('[case2] a test that needs a pre-populated directory', () => {
  when('[t0] genTempDir is called with { slug, clone: "path/to/fixture" }', () => {
    then('returns an absolute path to a new directory', () => { ... });
  });
});
```

**relation to wish:** reporter tests will follow same convention for organized scenarios.

### [REUSE] [tN] for when blocks

when blocks use `[t0]`, `[t1]`, etc. for temporal order.

**file:** `src/domain.operations/genTempDir/genTempDir.acceptance.jest.test.ts` [10]

```typescript
given('[case1] a test that needs a temporary directory', () => {
  when('[t0] genTempDir is called with a slug', () => {
    then('returns an absolute path to a new directory', () => { ... });
    then('the directory exists on the filesystem', () => { ... });
  });

  when('[t1] genTempDir is called multiple times in quick succession', () => {
    then('each call returns a unique directory path', () => { ... });
  });
});
```

**relation to wish:** reporter tests will use time indices for sequential scenarios.

---

## 7. integration test patterns

### [REUSE] cleanup arrays with afterEach

integration tests track created resources and clean up after each test.

**file:** `src/domain.operations/genTempDir/genTempDir.integration.jest.test.ts` [11]

```typescript
describe('genTempDir', () => {
  const createdDirs: string[] = [];

  beforeEach(() => {
    resetPruneThrottle();
  });

  afterEach(() => {
    // cleanup created temp directories
    for (const dir of createdDirs) {
      if (fs.existsSync(dir)) {
        fs.rmSync(dir, { recursive: true, force: true });
      }
    }
    createdDirs.length = 0;
  });

  given('genTempDir is called with a slug', () => {
    when('invoked', () => {
      then('it returns an absolute path to a new directory', () => {
        const tempDir = genTempDir({ slug: 'integration-test' });
        createdDirs.push(tempDir);

        expect(path.isAbsolute(tempDir)).toBe(true);
      });
    });
  });
});
```

**relation to wish:** reporter integration tests will track temp directories and output files for cleanup.

### [REUSE] inline fixture creation

tests create fixtures in beforeEach and clean up in afterEach.

**file:** `src/domain.operations/genTempDir/genTempDir.integration.jest.test.ts` [12]

```typescript
given('genTempDir is called with clone option', () => {
  const fixtureDir = path.join(__dirname, '.test-fixture');

  beforeEach(() => {
    // create a test fixture
    fs.mkdirSync(fixtureDir, { recursive: true });
    fs.writeFileSync(path.join(fixtureDir, 'test.txt'), 'hello world');
    fs.mkdirSync(path.join(fixtureDir, 'nested'));
    fs.writeFileSync(
      path.join(fixtureDir, 'nested', 'deep.txt'),
      'deep content',
    );
  });

  afterEach(() => {
    if (fs.existsSync(fixtureDir)) {
      fs.rmSync(fixtureDir, { recursive: true, force: true });
    }
  });
});
```

**relation to wish:** reporter tests may create fixture test suites to run and measure.

### [REUSE] helper functions for resource creation

integration tests use helper functions for repeated resource creation.

**file:** `src/infra/isomorph.fs/initGitRepo.integration.jest.test.ts` [13]

```typescript
const createTempDir = (): string => {
  const dir = fs.mkdtempSync(path.join(os.tmpdir(), 'initGitRepo-test-'));
  createdDirs.push(dir);
  return dir;
};

describe('initGitRepo', () => {
  const createdDirs: string[] = [];

  afterEach(() => {
    for (const dir of createdDirs) {
      if (fs.existsSync(dir)) {
        fs.rmSync(dir, { recursive: true, force: true });
      }
    }
    createdDirs.length = 0;
  });

  given('[case1] an empty directory', () => {
    when('[t0] initGitRepo is called', () => {
      then('it creates a valid git repository', () => {
        const dir = createTempDir();
        initGitRepo({ dir });

        expect(fs.existsSync(path.join(dir, '.git'))).toBe(true);
      });
    });
  });
});
```

**relation to wish:** reporter tests will use helper functions to create test suites for reporter execution.

---

## 8. git integration patterns

### [REUSE] git command verification via execSync

tests verify git operations via shell commands.

**file:** `src/infra/isomorph.fs/commitGitChanges.integration.jest.test.ts` [14]

```typescript
given('[case1] a git repo with staged files', () => {
  when('[t0] commitGitChanges is called', () => {
    then('it commits the files with the given message', () => {
      const dir = createGitRepo();

      // create a file
      fs.writeFileSync(path.join(dir, 'test.txt'), 'content');

      // commit
      commitGitChanges({ dir, message: 'my commit message' });

      // verify commit
      const log = execSync('git log --oneline', {
        cwd: dir,
      });
      expect(log.toString()).toContain('my commit message');
    });
  });
});
```

**relation to wish:** reporter tests may verify json output files and terminal output via shell commands.

---

## 9. jest vs vitest test patterns

### [REUSE] jest tests import from local module

jest tests import directly from the module under test.

**file:** `src/domain.operations/givenWhenThen.jest.test.ts` [15]

```typescript
import { given, then, when } from './givenWhenThen';

describe('doesPlantNeedWater', () => {
  given('a plant', () => {
    when('the plant doesnt have enough water', () => {
      const plant: Plant = { id: 7, hydration: 'DRY' };
      then('it should return true', () => {
        expect(doesPlantNeedWater(plant)).toEqual(true);
      });
    });
  });
});
```

**relation to wish:** reporter jest tests will import jest reporter class directly.

### [REUSE] vitest bdd tests use namespace

vitest bdd tests import `bdd` namespace to avoid thenable issues.

**file:** `src/domain.operations/givenWhenThen.vitest.bdd.test.ts` [16]

```typescript
import { describe, expect } from 'vitest';
import { bdd } from './givenWhenThen';

describe('givenWhenThen via bdd namespace', () => {
  describe('bdd.given/when/then', () => {
    bdd.given('bdd namespace is used', () => {
      bdd.when('tests are structured with bdd.given/when/then', () => {
        bdd.then('it should display the hierarchy correctly', () => {
          expect(true).toBe(true);
        });
      });
    });
  });
});
```

**relation to wish:** reporter vitest tests will use `bdd` namespace for test organization.

### [REUSE] vitest globals tests use global given/when/then

vitest globals tests assume globals from setup file.

**file:** `src/domain.operations/givenWhenThen.vitest.globals.test.ts` [17]

```typescript
import { describe, expect } from 'vitest';

describe('givenWhenThen', () => {
  describe('given', () => {
    given('given/when/then are used', () => {
      when('used for organize', () => {
        then('it should display the hierarchy correctly', () => {
          expect(true).toBe(true);
        });
      });
    });
  });
});
```

**relation to wish:** reporter vitest globals tests will use same pattern.

---

## 10. runner detection tests

### [REUSE] verify runner detection per environment

tests verify correct runner detection in each environment.

**file:** `src/infra/isomorph.test/detectTestRunner.jest.test.ts` [18]

```typescript
describe('detectTestRunner', () => {
  given('jest context', () => {
    when('detectTestRunner is called', () => {
      then('it should return jest', () => {
        expect(detectTestRunner()).toBe('jest');
      });
    });

    when('getTestRunner is called', () => {
      then('it should return jest', () => {
        expect(getTestRunner()).toBe('jest');
      });
    });
  });
});
```

**file:** `src/infra/isomorph.test/detectTestRunner.vitest.test.ts` [19]

```typescript
describe('detectTestRunner', () => {
  given('vitest context', () => {
    when('detectTestRunner is called', () => {
      then('it should return vitest', () => {
        expect(detectTestRunner()).toBe('vitest');
      });
    });
  });
});
```

**relation to wish:** reporter tests will verify correct reporter instantiation per runner.

---

## 11. acceptance test patterns

### [REUSE] comprehensive use case coverage

acceptance tests cover complete user workflows with multiple scenarios.

**file:** `src/domain.operations/genTempDir/genTempDir.acceptance.jest.test.ts` [20]

```typescript
describe('genTempDir acceptance', () => {
  const createdDirs: string[] = [];

  beforeEach(() => {
    resetPruneThrottle();
  });

  afterEach(() => {
    for (const dir of createdDirs) {
      if (fs.existsSync(dir)) {
        fs.rmSync(dir, { recursive: true, force: true });
      }
    }
    createdDirs.length = 0;
  });

  // usecase.1: generate an ephemeral temp directory
  given('[case1] a test that needs a temporary directory', () => {
    when('[t0] genTempDir is called with a slug', () => {
      then('returns an absolute path to a new directory', () => {
        const dir = genTempDir({ slug: 'acceptance-test' });
        createdDirs.push(dir);

        expect(path.isAbsolute(dir)).toBe(true);
      });

      then('the directory exists on the filesystem', () => {
        const dir = genTempDir({ slug: 'acceptance-test' });
        createdDirs.push(dir);

        expect(fs.existsSync(dir)).toBe(true);
        expect(fs.statSync(dir).isDirectory()).toBe(true);
      });
    });
  });
});
```

**relation to wish:** reporter acceptance tests will cover complete scenarios (configure reporter, run tests, verify terminal output, verify json file).

---

## 12. unit test patterns

### [REUSE] pure function tests with test data

unit tests use inline test data rather than external fixtures.

**file:** `src/domain.operations/genTempDir/computeStaleDirs.jest.test.ts` [21]

```typescript
describe('computeStaleDirs', () => {
  given('an empty list of directories', () => {
    when('computeStaleDirs is called', () => {
      then('it returns empty array', () => {
        const result = computeStaleDirs({ dirs: [], maxAgeMs: ONE_HOUR_MS });
        expect(result).toEqual([]);
      });
    });
  });

  given('directories with various ages', () => {
    const now = new Date('2026-01-19T14:00:00.000Z');
    const twoHoursAgo = '2026-01-19T12-00-00.000Z.stale-test.a1b2c3d4';
    const thirtyMinsAgo = '2026-01-19T13-30-00.000Z.recent-test.b2c3d4e5';

    const dirs: DirEntry[] = [
      { name: twoHoursAgo, path: `/tmp/.temp/${twoHoursAgo}` },
      { name: thirtyMinsAgo, path: `/tmp/.temp/${thirtyMinsAgo}` },
    ];

    when('filtered with 1 hour threshold', () => {
      then('it returns directories older than threshold', () => {
        const result = computeStaleDirs({
          dirs,
          maxAgeMs: ONE_HOUR_MS,
          now,
        });

        expect(result).toHaveLength(1);
        expect(result.map((d) => d.name)).toContain(twoHoursAgo);
      });
    });
  });
});
```

**relation to wish:** reporter unit tests will use inline test data (mock test results, mock config) for pure function tests (hierarchy builder, time formatter, threshold evaluator).

---

## 13. repeatably pattern

### [EXTEND] repeatably with SOME criteria

`then.repeatably` with `criteria: 'SOME'` retries until success — useful for flaky test scenarios.

**file:** `src/domain.operations/givenWhenThen.repeatably.jest.test.ts` [22]

```typescript
given('criteria = SOME', () => {
  const someExecutedAttempts: number[] = [];

  then.repeatably({ attempts: 5, criteria: 'SOME' })(
    'it should retry until success',
    ({ attempt }) => {
      someExecutedAttempts.push(attempt);
      // fails on attempts 1-3, passes on attempt 4+
      expect(attempt).toBeGreaterThan(3);
    },
  );

  afterAll(() => {
    expect(someExecutedAttempts).toEqual([1, 2, 3, 4]);
  });
});
```

**relation to wish:** may use for reporter tests that verify behavior under test variance (time jitter).

---

## summary table

| pattern | action | rationale |
|---------|--------|-----------|
| file suffix conventions | [REUSE] | follow same file names |
| given/when/then hierarchy | [REUSE] | test reporter with bdd |
| skip/todo modifiers | [REUSE] | incremental development |
| skipIf/runIf conditionals | [REUSE] | runner-specific tests |
| useBeforeAll | [REUSE] | expensive setup (run test suite) |
| useBeforeEach | [REUSE] | fresh reporter per test |
| useThen | [REUSE] | capture reporter output |
| useWhen | [REUSE] | baseline comparison tests |
| [caseN]/[tN] labels | [REUSE] | organized scenarios |
| cleanup arrays | [REUSE] | temp file cleanup |
| inline fixtures | [REUSE] | test suite fixtures |
| helper functions | [REUSE] | repeated resource creation |
| git verification | [REUSE] | verify output files |
| jest imports | [REUSE] | direct import for jest |
| vitest bdd namespace | [REUSE] | avoid thenable issues |
| vitest globals | [REUSE] | globals-based tests |
| runner detection tests | [REUSE] | verify per-runner behavior |
| acceptance coverage | [REUSE] | end-to-end scenarios |
| pure function tests | [REUSE] | unit test with inline data |
| repeatably SOME | [EXTEND] | flaky time variance |

---

## new patterns needed

the slowtest reporter tests require patterns not present in current test code:

1. **mock test suite runner** — create minimal test files, run jest/vitest programmatically, capture output
2. **reporter output parser** — parse terminal output to verify format
3. **json output verifier** — read and validate json report structure
4. **baseline file comparator** — verify delta calculation against baseline
5. **threshold boundary tests** — verify slow/not-slow classification at boundary values
6. **hierarchy reconstruction tests** — verify given/when/then tree from flat results

---

## citations

[1] src/domain.operations/givenWhenThen.jest.test.ts:6-23
[2] src/domain.operations/givenWhenThen.jest.test.ts:16-21
[3] src/domain.operations/givenWhenThen.jest.test.ts:37-61
[4] src/domain.operations/usePrep.jest.test.ts:8-28
[5] src/domain.operations/usePrep.jest.test.ts:30-45
[6] src/domain.operations/useThen.jest.test.ts:5-18
[7] src/domain.operations/useThen.jest.test.ts:87-106
[8] src/domain.operations/useWhen.jest.test.ts:10-47
[9] src/domain.operations/genTempDir/genTempDir.acceptance.jest.test.ts:26-35
[10] src/domain.operations/genTempDir/genTempDir.acceptance.jest.test.ts:26-40
[11] src/domain.operations/genTempDir/genTempDir.integration.jest.test.ts:7-31
[12] src/domain.operations/genTempDir/genTempDir.integration.jest.test.ts:80-98
[13] src/infra/isomorph.fs/initGitRepo.integration.jest.test.ts:8-41
[14] src/infra/isomorph.fs/commitGitChanges.integration.jest.test.ts:12-46
[15] src/domain.operations/givenWhenThen.jest.test.ts:1-10
[16] src/domain.operations/givenWhenThen.vitest.bdd.test.ts:8-21
[17] src/domain.operations/givenWhenThen.vitest.globals.test.ts:3-13
[18] src/infra/isomorph.test/detectTestRunner.jest.test.ts:5-19
[19] src/infra/isomorph.test/detectTestRunner.vitest.test.ts:5-19
[20] src/domain.operations/genTempDir/genTempDir.acceptance.jest.test.ts:9-50
[21] src/domain.operations/genTempDir/computeStaleDirs.jest.test.ts:7-50
[22] src/domain.operations/givenWhenThen.repeatably.jest.test.ts:156-173
