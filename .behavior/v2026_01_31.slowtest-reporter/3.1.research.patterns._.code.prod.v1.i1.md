# research: production code patterns

## summary

this document catalogs production codepath patterns in the test-fns repo relevant to the slowtest reporter feature. each pattern is marked as [REUSE], [EXTEND], or [REPLACE].

---

## 1. contract layer exports

### [EXTEND] public api surface via contract/index.ts

the contract layer provides the public api surface. slowtest reporter exports will be added here.

**file:** `src/contract/index.ts` [1]

```typescript
export { getError } from 'helpful-errors';
export { genTempDir, isTempDir } from '@src/domain.operations/genTempDir/genTempDir';
export { genTestUuid } from '@src/domain.operations/genTestUuid';
export { bdd, given, then, when } from '@src/domain.operations/givenWhenThen';
export { useBeforeAll, useBeforeEach, usePrep } from '@src/domain.operations/usePrep';
export { useThen } from '@src/domain.operations/useThen';
export { useWhen } from '@src/domain.operations/useWhen';
```

**relation to wish:** the reporter will add new exports (e.g., `slowtestReporter`, `slowtestReporter.jest`, `slowtestReporter.vitest`) to this contract layer.

---

## 2. test runner detection

### [REUSE] cached runner detection via environment variables

detects whether tests run under jest or vitest. essential for reporter api differences.

**file:** `src/infra/isomorph.test/detectTestRunner.ts` [2]

```typescript
export type TestRunner = 'vitest' | 'jest';

export const detectTestRunner = (): TestRunner => {
  if (process.env.VITEST !== undefined) return 'vitest';
  if (process.env.JEST_WORKER_ID !== undefined) return 'jest';
  throw new UnexpectedCodePathError(
    'detectTestRunner: no test runner detected. expected VITEST or JEST_WORKER_ID env var',
    { env: { VITEST: process.env.VITEST, JEST_WORKER_ID: process.env.JEST_WORKER_ID } },
  );
};

let runnerCached: TestRunner | undefined;
export const getTestRunner = (): TestRunner => {
  if (runnerCached === undefined) runnerCached = detectTestRunner();
  return runnerCached;
};
```

**relation to wish:** slowtest reporter needs to detect runner to instantiate the correct reporter class (jest vs vitest api).

---

## 3. test globals interface

### [REUSE] unified globals interface

provides framework-agnostic access to test primitives (`describe`, `test`, `beforeAll`, etc).

**file:** `src/infra/isomorph.test/getTestGlobals.ts` [3]

```typescript
export interface TestGlobals {
  describe: typeof describe;
  test: typeof test;
  beforeAll: typeof beforeAll;
  beforeEach: typeof beforeEach;
  afterAll: typeof afterAll;
  afterEach: typeof afterEach;
}

export const globals = (): TestGlobals => {
  if (!cachedGlobals) cachedGlobals = getTestGlobals();
  return cachedGlobals;
};
```

**relation to wish:** reporter may use `globals().afterAll` to flush time data at end of test run if needed for internal records.

---

## 4. describe stack hierarchy

### [REUSE] stack-based hierarchy track via describe path

tracks the full describe block hierarchy as tests register. provides full path for each block.

**file:** `src/domain.operations/registryDescribeRepeatable.ts` [4]

```typescript
const describeStack: string[] = [];

export const getDescribePath = (): string => describeStack.join(' > ');

export const wrapDescribeCallback = (input: {
  name: string;
  fn: () => void;
}): (() => void) => {
  const capturedCtx = getCurrentRepeatableContext();
  return () => {
    describeStack.push(input.name);
    const prevCtx = getCurrentRepeatableContext();
    if (capturedCtx) setCurrentRepeatableContext(capturedCtx);
    try {
      input.fn();
    } finally {
      setCurrentRepeatableContext(prevCtx);
      describeStack.pop();
    }
  };
};
```

**relation to wish:** the `getDescribePath()` function provides the hierarchical path (e.g., `"given: [case1] overdue invoice > when: [t0] nurture triggered"`) that the reporter needs to build nested block output. however, note that this tracks collection-time hierarchy, not execution-time — the reporter must reconstruct from `ancestorTitles` (jest) or `fullName` (vitest).

---

## 5. given/when/then implementation

### [REUSE] describe delegation with prefix

`given` and `when` delegate to `globals().describe()` with prefixed names.

**file:** `src/domain.operations/givenWhenThen.ts` [5]

```typescript
export const given: Describe = (<F extends () => void>(
  desc: string,
  fn: SyncCallback<F>,
): void => {
  const name = `given: ${desc}`;
  globals().describe(
    name,
    wrapDescribeCallback({ name, fn: fn as () => void }),
  );
}) as Describe;
```

**relation to wish:** the `given: `, `when: `, `then: ` prefixes enable the reporter to identify block types from test names. parser can extract type via prefix match.

### [REUSE] test delegation with prefix

`then` delegates to `globals().test()` with prefixed name.

**file:** `src/domain.operations/givenWhenThen.ts` [6]

```typescript
const then: Test = ((...input: TestInput<void>): void => {
  const [name, testFn] = castToTestInput({ input, prefix: 'then' });
  const repeatableCtx = getCurrentRepeatableContext();

  if (!repeatableCtx || repeatableCtx.criteria !== 'SOME') {
    globals().test(name, testFn);
    return;
  }
  // repeatably logic...
}) as Test;
```

**relation to wish:** all tests have `then: ` prefix, which the reporter uses to identify leaf tests vs describe blocks.

---

## 6. vitest setup pattern

### [EXTEND] setup file for globals registration

vitest setup file registers globals to work around thenable detection.

**file:** `src/contract/vitest.setup.ts` [7]

```typescript
import { bdd } from './index';

declare global {
  var given: typeof bdd.given;
  var when: typeof bdd.when;
  var then: typeof bdd.then;
}

globalThis.given = bdd.given;
globalThis.when = bdd.when;
globalThis.then = bdd.then;
```

**relation to wish:** vitest reporter may need a similar setup file pattern, or the reporter can be instantiated directly in vitest.config.ts without globals.

---

## 7. vitest config pattern

### [EXTEND] vitest configuration with setup files

vitest config shows how to register setup files and configure test environment.

**file:** `vitest.unit.globals.config.ts` [8]

```typescript
export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    setupFiles: ['./src/contract/vitest.setup.ts'],
    include: ['**/*.vitest.test.ts', '**/*.vitest.globals.test.ts'],
    exclude: ['**/node_modules/**', '**/.yalc/**', '**/*.vitest.bdd.test.ts'],
  },
  resolve: { alias: { '@src': path.resolve(__dirname, './src') } },
});
```

**relation to wish:** slowtest reporter vitest integration will follow similar pattern — users add to `reporters` array in their vitest.config.ts.

---

## 8. jest config pattern

### [EXTEND] jest configuration with reporters

jest config shows how reporters are configured.

**file:** `jest.unit.config.ts` [9]

```typescript
const config: JestConfigWithTsJest = {
  testEnvironment: 'node',
  verbose: true,
  testPathIgnorePatterns: ['/node_modules/', '/dist/', '/.yalc/'],
  modulePathIgnorePatterns: ['/.yalc/'],
  testMatch: ['**/*.test.ts'],
  moduleNameMapper: { '^@src/(.*)$': '<rootDir>/src/$1' },
  transform: { '^.+\\.tsx?$': ['@swc/jest', {}] },
};

export default config;
```

**relation to wish:** slowtest reporter jest integration adds to the `reporters` array (not shown in current config, as no custom reporters exist yet).

---

## 9. thenable detection workaround

### [REUSE] known constraint for api design

vitest's dynamic import triggers thenable detection on any module with callable `then` export.

**file:** `src/domain.operations/givenWhenThen.ts` [10]

```typescript
const thenExportable: Test = ((...input: TestInput<void>): any => {
  if (typeof input[0] === 'function') {
    (input[0] as (v: unknown) => void)({ given, when, bdd, getNumberRange });
    return;
  }
  then(...input);
}) as Test;

export { thenExportable as then };
```

**relation to wish:** the reporter module must not export a callable `then` at top level if it's to be imported by vitest users. use namespace pattern (e.g., `slowtestReporter.vitest()`) or factory function.

---

## 10. proxy pattern for deferred access

### [REUSE] known pattern for deferred value access

`usePrep` and `useThen` use proxies to defer value access until hooks execute.

**file:** `src/domain.operations/usePrep.ts` [11]

```typescript
const proxyHandler: ProxyHandler<any> = {
  get(_, prop) {
    if (toolbox === undefined)
      throw new UnexpectedCodePathError('usePrep: tried to access value before setup completed');
    return (toolbox as any)[prop];
  },
  ownKeys() { return Reflect.ownKeys(drawer); },
  getOwnPropertyDescriptor(_, prop) { return Object.getOwnPropertyDescriptor(drawer, prop); },
  apply() { throw new Error('usePrep: value is not callable'); },
};
```

**relation to wish:** reporter may use similar proxy pattern if it needs to expose time data that's only available after test run completes.

---

## 11. repeatably state registry

### [REUSE] known pattern for state accumulation

registry maps describe paths to mutable state objects shared across attempts.

**file:** `src/domain.operations/registryDescribeRepeatable.ts` [12]

```typescript
export const registryDescribeRepeatable = new Map<string, RepeatableState>();

export const findRepeatableContext = (
  path: string,
): RepeatableState | undefined => {
  const exact = registryDescribeRepeatable.get(path);
  if (exact) return exact;

  const parts = path.split(' > ');
  while (parts.length > 0) {
    parts.pop();
    const parentPath = parts.join(' > ');
    const parent = registryDescribeRepeatable.get(parentPath);
    if (parent) return parent;
  }
  return undefined;
};
```

**relation to wish:** slowtest reporter may use a similar registry pattern to accumulate time data per file/block as test execution proceeds.

---

## 12. temp dir timestamp pattern

### [REUSE] known pattern for timestamped output

temp dir names embed iso timestamps for age-based operations without stat calls.

**file:** `src/domain.operations/genTempDir/computeTempDirName.ts` [13]

```typescript
export const computeTempDirName = (input: { slug: string }): string => {
  const timestamp = new Date().toISOString().replace(/:/g, '-');
  const suffix = uuid().replace(/-/g, '').slice(0, 8);
  return `${timestamp}.${slug}.${suffix}`;
};
```

**relation to wish:** json output files may include timestamp in filename for historical comparison (e.g., `.slowtest/report.2026-01-31T14-23-00.json`).

---

## 13. error pattern

### [REUSE] fail-fast with helpful errors

uses `UnexpectedCodePathError` for invariant violations.

**file:** `src/infra/isomorph.test/detectTestRunner.ts` [14]

```typescript
throw new UnexpectedCodePathError(
  'detectTestRunner: no test runner detected. expected VITEST or JEST_WORKER_ID env var',
  { env: { VITEST: process.env.VITEST, JEST_WORKER_ID: process.env.JEST_WORKER_ID } },
);
```

**relation to wish:** reporter will use same error pattern for invalid configuration or unexpected states.

---

## summary table

| pattern | action | rationale |
|---------|--------|-----------|
| contract layer exports | [EXTEND] | add slowtest reporter exports |
| test runner detection | [REUSE] | detect jest vs vitest for api selection |
| test globals interface | [REUSE] | access `afterAll` if needed |
| describe stack hierarchy | [REUSE] | known mechanism (but reporter uses runner apis instead) |
| given/when/then prefixes | [REUSE] | parse block types from test names |
| vitest setup pattern | [EXTEND] | may add reporter setup if needed |
| vitest config pattern | [EXTEND] | document reporter config |
| jest config pattern | [EXTEND] | document reporter config |
| thenable workaround | [REUSE] | avoid `then` export at top level |
| proxy pattern | [REUSE] | may use for deferred time access |
| state registry pattern | [REUSE] | accumulate time data per block |
| temp dir timestamps | [REUSE] | timestamp output files |
| fail-fast errors | [REUSE] | consistent error management |

---

## new patterns needed

the slowtest reporter requires patterns not present in the current codebase:

1. **jest reporter class** — implement `Reporter` interface with `onTestFileResult`, `onRunComplete` hooks
2. **vitest reporter class** — implement `Reporter` interface with `onTestCaseResult`, `onTestModuleEnd` hooks
3. **time accumulator** — collect per-file and per-block durations as execution proceeds
4. **hierarchy builder** — reconstruct given/when/then tree from flat test results
5. **terminal formatter** — render time table to stdout
6. **json serializer** — write time data to file with optional shard format
7. **threshold evaluator** — classify files as slow based on configured threshold
8. **baseline comparator** — compute deltas vs prior run

---

## citations

[1] src/contract/index.ts:1-23
[2] src/infra/isomorph.test/detectTestRunner.ts:15-46
[3] src/infra/isomorph.test/getTestGlobals.ts:17-80
[4] src/domain.operations/registryDescribeRepeatable.ts:10-16,106-124
[5] src/domain.operations/givenWhenThen.ts:155-180
[6] src/domain.operations/givenWhenThen.ts:375-395
[7] src/contract/vitest.setup.ts:1-58
[8] vitest.unit.globals.config.ts:10-26
[9] jest.unit.config.ts:1-20
[10] src/domain.operations/givenWhenThen.ts:562-578
[11] src/domain.operations/usePrep.ts:25-35
[12] src/domain.operations/registryDescribeRepeatable.ts:46,82-99
[13] src/domain.operations/genTempDir/computeTempDirName.ts:12-18
[14] src/infra/isomorph.test/detectTestRunner.ts:18-21
