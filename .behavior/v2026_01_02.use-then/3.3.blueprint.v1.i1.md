# blueprint: useThen and useWhen

## blackbox criteria satisfied

- usecase.1 = share operation response across multiple then assertions ✓
- usecase.2 = share operation response across multiple when blocks ✓
- usecase.3 = verify idempotency pattern ✓
- usecase.4 = isomorphic test runner support ✓
- usecase.5 = primitive and object return values ✓ (objects directly; primitives via wrapper)

## design decisions

### proxy pattern

follow the established `usePrep` pattern:
- return a proxy that defers access until the test/setup runs
- use drawer/toolbox metaphor for clarity
- throw `UnexpectedCodePathError` on premature access

### type constraint

```ts
T extends Record<string, any>
```

primitives must be wrapped: `useThen('...', () => ({ value: 42 }))`

rationale: javascript proxies cannot wrap primitive values directly. this matches the existing `usePrep` constraint.

### test execution order

tests within a describe block run in registration order. `useThen` registers its test first, so by the time subsequent `then` blocks execute, the value is available.

```ts
useThen('a', () => value)  // registers test #1
then('b', () => use(value)) // registers test #2
// execution: test #1 runs, stores value, then test #2 runs
```

## subcomponent contracts

### useThen contract

```ts
given('useThen contract')
  then('exposes: useThen<T>(desc: string, fn: () => Promise<T> | T): T')
  then('registers a test with prefix "then: {desc}"')
  then('returns a proxy to the function return value')
  then('proxy throws on access before test runs')
  then('proxy provides direct access after test runs')

given('useThen modifiers')
  then('exposes: useThen.only(desc, fn) — only run this test')
  then('exposes: useThen.skip(desc, fn) — skip this test')
  then('exposes: useThen.skipIf(condition)(desc, fn) — conditionally skip')
  then('exposes: useThen.runIf(condition)(desc, fn) — conditionally run')
  then('all modifiers return the same proxy type as useThen')
```

### useWhen contract

```ts
given('useWhen contract')
  then('exposes: useWhen<T>(desc: string, fn: () => T): T')
  then('registers a describe block with prefix "when: {desc}"')
  then('executes fn synchronously at registration time')
  then('returns whatever fn returns')

given('useWhen modifiers')
  then('exposes: useWhen.only(desc, fn) — only run this describe')
  then('exposes: useWhen.skip(desc, fn) — skip this describe')
  then('exposes: useWhen.skipIf(condition)(desc, fn) — conditionally skip')
  then('exposes: useWhen.runIf(condition)(desc, fn) — conditionally run')
  then('all modifiers return the same type as useWhen')
```

## implementation approach

### useThen implementation

location: `src/domain.operations/useThen.ts`

```ts
/**
 * .what = register a test and capture its return value for subsequent assertions
 * .why = eliminates `let` declarations for sharing operation results between then blocks
 */

// helper to create the proxy pattern (reused by modifiers)
const createUseThenProxy = <T extends Record<string, any>>(
  desc: string,
  fn: () => Promise<T> | T,
  thenFn: typeof then,
): T => {
  // metaphor: "drawer" = proxy target, "toolbox" = real resolved resource
  const drawer: Partial<T> = {};
  let toolbox: T | undefined;

  // declare proxy handler up front so we can mutate it
  const proxyHandler: ProxyHandler<any> = {
    get(_, prop) {
      if (toolbox === undefined)
        throw new UnexpectedCodePathError(
          'useThen: tried to access value before test ran',
        );
      return (toolbox as any)[prop];
    },
    ownKeys() {
      return Reflect.ownKeys(drawer);
    },
    getOwnPropertyDescriptor(_, prop) {
      return Object.getOwnPropertyDescriptor(drawer, prop);
    },
  };

  // register the test via the provided then function (or modifier)
  thenFn(desc, async () => {
    toolbox = await fn();
    Object.assign(drawer, toolbox);
    delete proxyHandler.get;
  });

  return new Proxy(drawer, proxyHandler) as T;
};

// main function
export const useThen = <T extends Record<string, any>>(
  desc: string,
  fn: () => Promise<T> | T,
): T => createUseThenProxy(desc, fn, then);

// modifiers
useThen.only = <T extends Record<string, any>>(
  desc: string,
  fn: () => Promise<T> | T,
): T => createUseThenProxy(desc, fn, then.only);

useThen.skip = <T extends Record<string, any>>(
  desc: string,
  fn: () => Promise<T> | T,
): T => createUseThenProxy(desc, fn, then.skip);

useThen.skipIf = (condition: boolean) =>
  <T extends Record<string, any>>(desc: string, fn: () => Promise<T> | T): T =>
    createUseThenProxy(desc, fn, then.skipIf(condition));

useThen.runIf = (condition: boolean) =>
  <T extends Record<string, any>>(desc: string, fn: () => Promise<T> | T): T =>
    createUseThenProxy(desc, fn, then.runIf(condition));
```

### useWhen implementation

location: `src/domain.operations/useWhen.ts`

```ts
/**
 * .what = register a when block and capture its return value for sibling blocks
 * .why = enables sharing operation results across sequential when blocks (t1 → t2)
 */

// helper to create useWhen pattern (reused by modifiers)
const createUseWhen = <T>(
  desc: string,
  fn: () => T,
  whenFn: typeof when,
): T => {
  let result: T;

  whenFn(desc, () => {
    result = fn();
  });

  // result is assigned synchronously because when() executes fn immediately
  return result!;
};

// main function
export const useWhen = <T>(desc: string, fn: () => T): T =>
  createUseWhen(desc, fn, when);

// modifiers
useWhen.only = <T>(desc: string, fn: () => T): T =>
  createUseWhen(desc, fn, when.only);

useWhen.skip = <T>(desc: string, fn: () => T): T =>
  createUseWhen(desc, fn, when.skip);

useWhen.skipIf = (condition: boolean) =>
  <T>(desc: string, fn: () => T): T =>
    createUseWhen(desc, fn, when.skipIf(condition));

useWhen.runIf = (condition: boolean) =>
  <T>(desc: string, fn: () => T): T =>
    createUseWhen(desc, fn, when.runIf(condition));
```

## composition boundaries

### integration with existing exports

```ts
// src/contract/index.ts additions
export { useThen } from '@src/domain.operations/useThen';
export { useWhen } from '@src/domain.operations/useWhen';

// also add to bdd namespace for vitest compatibility
export const bdd = { given, when, then, useThen, useWhen };
```

### internal dependencies

```
useThen
  └── then (from givenWhenThen.ts)
  └── UnexpectedCodePathError (from helpful-errors)

useWhen
  └── when (from givenWhenThen.ts)
```

## test coverage criteria

### unit tests

```ts
given('useThen unit tests')
  then('has tests for proxy behavior before test runs')
  then('has tests for proxy behavior after test runs')
  then('has tests for async function support')
  then('has tests for sync function support')
  then('has tests for Object.keys() on proxy')
  then('has tests for useThen.only modifier')
  then('has tests for useThen.skip modifier')
  then('has tests for useThen.skipIf modifier')
  then('has tests for useThen.runIf modifier')

given('useWhen unit tests')
  then('has tests for synchronous callback execution')
  then('has tests for return value capture')
  then('has tests for useWhen.only modifier')
  then('has tests for useWhen.skip modifier')
  then('has tests for useWhen.skipIf modifier')
  then('has tests for useWhen.runIf modifier')
```

### integration tests (jest + vitest)

```ts
given('useThen integration tests')
  then('has jest test: registers test with correct name')
  then('has jest test: value accessible in subsequent then blocks')
  then('has vitest test: registers test with correct name')
  then('has vitest test: value accessible in subsequent then blocks')

given('useWhen integration tests')
  then('has jest test: registers describe with correct name')
  then('has jest test: return value accessible in sibling when blocks')
  then('has vitest test: registers describe with correct name')
  then('has vitest test: return value accessible in sibling when blocks')
```

### acceptance tests (full usecase)

```ts
given('idempotency pattern acceptance test')
  then('has test: t1 captures response via useThen')
  then('has test: t2 compares response to t1 responseFirst')
  then('has test: demonstrates full wish example pattern')
```

## file structure

```
src/domain.operations/
  useThen.ts                      # implementation
  useThen.jest.test.ts            # jest integration test
  useThen.vitest.test.ts          # vitest integration test
  useWhen.ts                      # implementation
  useWhen.jest.test.ts            # jest integration test
  useWhen.vitest.test.ts          # vitest integration test

src/contract/
  index.ts                        # add exports
```

## readme update

add section after `useBeforeEach`:

```markdown
### useThen

capture an operation's return value for use in subsequent assertions, without `let` declarations

\`\`\`ts
given('operation behavior', () => {
  when('[t1] operation is called', () => {
    const response = useThen('operation succeeds', async () => {
      return await doOperation({ input: 'test' });
    });

    then('response has expected shape', () => {
      expect(response.status).toEqual('success');
    });

    then('response contains expected data', () => {
      expect(response.data.id).toBeDefined();
    });
  });
});
\`\`\`

### useWhen

capture a when block's return value for use in sibling when blocks (useful for idempotency testing)

\`\`\`ts
given('idempotent operation', () => {
  const responseFirst = useWhen('[t1] operation is called first time', () => {
    const response = useThen('operation succeeds', async () => {
      return await doOperation({ input: 'test' });
    });
    return response;
  });

  when('[t2] operation is called second time', () => {
    const responseSecond = useThen('operation still succeeds', async () => {
      return await doOperation({ input: 'test' });
    });

    then('response is idempotent', () => {
      expect(responseSecond).toEqual(responseFirst);
    });
  });
});
\`\`\`

### when to use each

| function | purpose | timing | use for |
|----------|---------|--------|---------|
| `useBeforeAll` | prepare scene | before all tests | database connections, fixtures, initial state |
| `useBeforeEach` | prepare fresh scene | before each test | mutable resources that need reset |
| `useThen` | capture assertion result | during test | operation responses, visible in test output |
| `useWhen` | capture when block result | during registration | sharing results across sequential when blocks |

**scene preparation vs test assertions:**

- **useBeforeAll/useBeforeEach** = scene preparation
  - runs *before* test timers start
  - not visible in test output
  - use for: fixtures, connections, initial conditions

- **useThen/useWhen** = test assertions
  - runs *during* test execution
  - visible in test output ("then: operation succeeds")
  - use for: the actual operations you're testing

### immutability: safer, simpler tests

these hooks eliminate `let` declarations, enabling fully immutable test code:

\`\`\`ts
// ❌ before: mutable, error-prone
let response;
then('it succeeds', async () => {
  response = await doOperation();  // mutation
});
then('it has data', () => {
  expect(response.data).toBeDefined();  // depends on mutation order
});

// ✅ after: immutable, safe
const response = useThen('it succeeds', async () => {
  return await doOperation();  // no mutation
});
then('it has data', () => {
  expect(response.data).toBeDefined();  // guaranteed access
});
\`\`\`

benefits of immutability:
- **no ordering bugs** — can't accidentally access before assignment
- **clear data flow** — `const` declarations show exactly where values come from
- **safer refactoring** — move tests around without breaking variable scope
- **parallel-ready** — no shared mutable state between tests
```

## implementation order

1. implement `useThen.ts`
2. add jest integration test `useThen.jest.test.ts`
3. add vitest integration test `useThen.vitest.test.ts`
4. implement `useWhen.ts`
5. add jest integration test `useWhen.jest.test.ts`
6. add vitest integration test `useWhen.vitest.test.ts`
7. update `src/contract/index.ts` with exports
8. update `bdd` namespace in `givenWhenThen.ts`
9. update `readme.md` with documentation
10. run full test suite to verify isomorphic behavior
