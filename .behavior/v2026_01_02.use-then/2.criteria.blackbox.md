# usecase.1 = share operation response across multiple then assertions

given('a test suite with useThen')
  when('useThen is called with a description and async function')
    then('a test is registered with the description')
      sothat('the operation execution is visible in test output')
    then('the function executes during test run')
      sothat('the operation runs at the expected time')
    then('the return value is accessible in subsequent then blocks')
      sothat('users can assert on the response without `let` declarations')

given('a test suite with useThen')
  when('subsequent then blocks access the useThen return value')
    then('the value is available synchronously')
      sothat('users write `expect(response.foo)` without await')
    then('the value reflects what the useThen function returned')
      sothat('assertions operate on the real response')

given('a test suite with useThen')
  when('code tries to access the return value before the test runs')
    then('an error is thrown')
      sothat('users get clear feedback about incorrect access timing')


# usecase.2 = share operation response across multiple when blocks

given('a test suite with useWhen')
  when('useWhen is called with a description and function')
    then('a describe block is registered with the description')
      sothat('the when block is visible in test output')
    then('the return value is accessible in subsequent when blocks')
      sothat('users can reference prior operation results (e.g., responseFirst in t2)')

given('a test suite with useWhen containing useThen')
  when('useThen returns a value inside useWhen')
    then('the value can be returned from useWhen')
      sothat('users chain: `const responseFirst = useWhen(..., () => { return useThen(...) })`')
    then('the useWhen return value is accessible in sibling when blocks')
      sothat('t2 can compare its response to t1')


# usecase.3 = verify idempotency pattern

given('a test suite testing idempotent operations')
  when('t1 executes operation and captures response via useThen')
    then('responseFirst is accessible')
  when('t2 executes same operation and captures response via useThen')
    then('responseSecond is accessible')
    then('responseFirst is still accessible')
      sothat('users can assert `expect(responseSecond).toEqual(responseFirst)`')


# usecase.4 = isomorphic test runner support

given('a test suite using useThen')
  when('tests run under jest')
    then('useThen registers and executes correctly')
      sothat('jest users have full functionality')

given('a test suite using useThen')
  when('tests run under vitest')
    then('useThen registers and executes correctly')
      sothat('vitest users have full functionality')


# usecase.5 = primitive and object return values

given('useThen with a function returning an object')
  when('the function returns { foo: 'bar' }')
    then('accessing .foo returns "bar"')
      sothat('object properties are accessible')

given('useThen with a function returning a primitive')
  when('the function returns a string or number directly')
    then('the value is accessible')
      sothat('users can return primitives without wrapping in object')
